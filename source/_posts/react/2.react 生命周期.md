---
title: 2.react 生命周期
categories: React
tags: react
date: 2022-10-12 10:28:00
---

## react 生命周期
### 1.初始化阶段
> * ~~componentWillMount~~: render之前最后一次修改的机会 （16.2版本之后建议弃用， **UNSAFE_componentWillMount**替代，否则控制台警告）
> * render: 只访问this.props和this.state，不允许修改状态和DOM输出
> * componentDidMount: 成功render并渲染完成真实DOM之后触发，可以修改DOM
>   (1) 数据请求axios
>   (2) 订阅函数调用
>   (3) setInterval 
>   (4)基于创建完的dom进行初始化...

### 2.运行中阶段
> * ~~componentWillReceiveProps~~: 父组件修改属性触发子组件钩子函数(**UNSAFE_componentWillReceiveProps** 控制台不会警告)
> * shouldComponentUpdate: 返回false会阻止render调用
> * ~~componentWillUpdate~~:  更新前的钩子，不能修改属性状态(**UNSAFE_componentWillUpdate**替代，否则控制台警告)
> * render: 只能访问this.props和this.state，不允许修改状态和DOM输出
> * componentDidUpdate: 更新后的钩子 可以修改DOM

#### componentWillReceiveProps 
父组件修改属性触发子组件钩子函数 **UNSAFE_componentWillReceiveProps**
> * 1.最先获取父组件传来的属性，可以利用属性进行ajax或者逻辑处理
> * 2.把属性转化成孩纸自己的状态

```bash
class Child extends Component {
    state = {
        title: ''
    }
    render () {
        return <div>child {this.state.title}</div>
    }
    componentWillReceiveProps (nextProps) {
         this.setState({
            title: nextProps.text + 'kevint'
        })
    }
}

class App extends Component {
    state = {
        text: '11111111111111'
    }
  render() {
    return (
      <div>
         {this.state.text}
         <button onClick={() => this.setState({text: 222222222222})}>点击</button>
        <Child text={this.state.text}></Child>
      </div>
    )
  }
}
```

#### componentDidUpdate 更新后的钩子 可以修改DOM
**接口两个参数，修改前的props和state数据**
```bash
componentDidUpdate (prevProps, prevtate) {
    console.log(oldState, newState)
    console.log(this.state.list)
}
```   

#### shouldComponentUpdate 返回false会阻止render调用
return false render函数不更新，return true render函数更新
接受两个参数，新的props参数，新的state参数
```bash
shouldComponentUpdate (nextProps, nextState) {
    console.log(nextProps, nextState)
    if (this.state.myname === 'xiaoming') return false
    return true
}
```


### 3.销毁阶段
> * componentWillUnmount: 在删除组件之前进行清理操作，比如计时器和事件监听器

### 4.老生命周期的问题
（1）componentWillMount, 在ssr中这个方法将会被多次调用，所以会重复触发多遍，同时在这里如果绑定事件，将无法解绑，导致内存泄漏，变的不够安全高效逐步废弃
（2）componentWillReceiveProps 外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求
（3）componentWillUpdate，更新前记录DOM状态，可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致状态不可信

### 5.新生命周期的替代
#### (1) getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的state，返回null则说明不需要再这里更新state
getDerivedStateFromProps 总不能进行异步处理
##### 案例1
```bash
state = {
    myName: 'adsafasd'
}
# 初始化，或者数据改变，都会触发，return返回的参数会合并到state上面
static getDerivedStateFromProps (nextProps, nextState) {
    return {
        myName: nextState.myName.substring(0, 1).toUpperCase() + nextState.myName.substring(1)
    }
}
render() {
    return (
        <div>
            <button onClick={() => this.setState({myName: 'fdgsdfgdfs'})}>点击</button>
            {this.state.myName}
            {this.state.age}
        </div>
    )
}
```
##### 案例2
> * 1.getDerivedStateFromProps 中不能进行异步处理，所以需要进行状态管理，配合componentDidUpdate触发
> * 2.componentDidUpdate 需要异步请求前，需要加个锁

```bash
class FilmList extends Component {
    state = {
        list: '',
        type: null
    }
    static getDerivedStateFromProps (nextProps) {
        return {type: nextProps.type}
    }
    async componentDidUpdate (prevProps, prevtate) {
        console.log(this.state.type, 'stte.type')
        if (this.state.type === prevProps.type) return
        # 假装下面代码是 接口回调
        # await
        this.setState({
            list: this.state.type + '2222222222222'
        })
    }
    render () {
        return (
            <div>
                {this.props.type}
                <p>{this.state.list}</p>
            </div>
            
        )
    }
}

class App extends Component {
    state = {
        type: 1
    }
  render() {
    return (
      <div>
        <ul>
            <li onClick={() => this.setState({type: 1})}>正在热映</li>
            <li onClick={() => this.setState({type: 2})}>即将上映</li>
        </ul>

        <FilmList type={this.state.type}></FilmList>
      </div>
    )
  }
}

```
#### (2) getSnapshotBeforeUpdate 取代componentWillUpdate, 触发时间为update发生时候，在render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数

**案例1**
必须返回一个值
```bash
getSnapshotBeforeUpdate () {
    console.log(3333333333)
    return 1111
}
componentDidUpdate (prevProps, prevState, value) {
    console.log(prevProps, prevState, value) # value -> 111
}
```

**案例2**
```bash
state = {
    list: [1, 2, 3, 4, 5, 6, 7, 8, 9]
}
myref = React.createRef()
getSnapshotBeforeUpdate() {
    # 获取容器高度
    return this.myref.current.scrollHeight
}
componentDidUpdate (prevProps, prevState, value) {
    this.myref.current.scrollTop += this.myref.current.scrollHeight - value
}
render() {
    return (
        <div>
            <button onClick={() => {
                this.setState({
                    list: [...[11, 12, 13, 14, 15, 16, 17, 18], ...this.state.list]
                })
            }}>
                收邮件
            </button>
            <h1>邮箱应用</h1>

            <div style={{ height: '200px', overflow: 'auto' }} ref={this.myref}>

                <ul>
                    {
                        this.state.list.map(item =>
                            <li style={{ height: '100px', background: 'red' }} key={item}>{item}</li>
                        )
                    }
                </ul>
            </div>
        </div>
    )
}
```

### 6.react中性能优化的方案
#### 1.shouldComponentUpdate
控制组件自身或者子组件是否需要更新，尤其在子组件非常多的情况下，需要进行优化
#### 2.PureComponent
**PureComponent**会帮你比较新的`props`跟旧的`props`,新的`state`和老的`state`（值相等，或者对象含有相同的属性，且属性值相等），决定**shouldComponentUpdate**返回true或者false，从而决定要不要呼叫render function。

**注意：**
如果你的state或props【永远都不会变】，那**PureComponent**并不会比较快，因为shallowEqual也需要花时间

```bash
import React, { PureComponent, Component } from 'react'

export default class App extends PureComponent {
    state = {
        myname: 'kerwin'
    }
    # PureComponent 相当于下面函数注释打开
    # shouldComponentUpdate (nextProps, nextState) {
    #     console.log(nextProps, nextState)
    #     if (this.state.myname === 'xiaoming') return false
    #     return true
    # }
    render() {
        # 如果用来PureComponent 不会多次执行render
        console.log(22222222)
        return (
            <div>
                <button onClick={() => {
                    this.setState({
                        myname: 'xiaoming'
                    })
                }}>click</button>
                {this.state.myname}
            </div>
        )
    }
}

```


### 7.react之swiper轮播组件
```bash
import React, { Component } from 'react'
import Swiper, {Navigation, Pagination} from 'swiper'
import 'swiper/swiper-bundle.min.css'
Swiper.use([Navigation, Pagination])

export default class App extends Component {
    state = {
        list: ["1111", "2222", "3333"]
    }
    componentDidMount () {
        # 同步
        new Swiper ('.swiper', {
            # direction: 'vertical', # 垂直切换选项
            # loop: true, # 循环模式选项
            
            # 如果需要分页器
            pagination: {
              el: '.swiper-pagination',
            },
            
            # 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            
            # 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })        
    }
    # 如果是异步，可以在这边new Swiper
    componentDidUpdate () {

    },
    render() {
        return (
            <div className="swiper">
                <div className="swiper-wrapper" style={{height: '200px', background: 'red'}}>
                    {
                        this.state.list.map(item => (
                            <div key={item} className="swiper-slide">Slide {item}</div>
                        ))
                    }
                </div>
                {/* <!-- 如果需要分页器 --> */}
                <div className="swiper-pagination"></div>
                
                {/* <!-- 如果需要导航按钮 --> */}
                <div className="swiper-button-prev"></div>
                <div className="swiper-button-next"></div>
                
                {/* <!-- 如果需要滚动条 --> */}
                <div className="swiper-scrollbar"></div>
            </div>
        )
    }
}
```