---
title: 技术面试之十代码篇
categories: 2023前端面试梳理
tags: 面试题
date: 2023-04-30 09:48:00
---

## 一、手写代码

### 1.手写promise（简易版）
```bash
class MyPromise {
    constructor (fn) {
        # 存储reslove回调函数列表
        this.callbacks = [];
        const resolve = (value) => {
            this.data = value # 返回值给后面的 .then
            while (this.callbacks.length) {
                let cb = this.callbacks.shift();
                cb(value)
            }
        }
        fn(resolve);
    }
    then(onResolvedCallback) {
        return new MyPromise(resolve => {
            this.callbacks.push(() => {
                const res = onResolvedCallback(this.data);
                if (res instanceof MyPromise) {
                    res.then(resolve)
                } else {
                    resolve(res)
                }
            })
        })
    }
}

// 这是测试案例
new MyPromise((resolve) => {
  setTimeout(() => {
    resolve(1)
  }, 1000)
}).then((res) => {
    console.log(res)
    return new MyPromise((resolve) => {
      setTimeout(() => {
        resolve(2)
      }, 1000)
    })
}).then(res =>{console.log(res)})

```

### 2.防抖节流
```bash
# 防抖
function debounce(fn, date) {
    let timer; # 声明接收定时器的变量
    return function (...arg) { # 获取参数
        timer && clearTimeout(timer); # 清空定时器
        # 生成新的定时器
        timer = setTimeout(() => {  
            # 因为箭头函数里的this指向上层作用域的this,所以这里可以直接用this，不需要声明其他的变量来接收
            fn.apply(this, arg); 
        }, date)
    }
}

# 节流
function debounce (fn, date) {
    let timer = +new date(); # 声明初始时间
    return function (...arg) { # 获取参数
        let newTimer = +new Date(); # 获取触发事件的时间
        if (newTimer - timer >= data) { # 时间判断,是否满足条件
            fn.apply(this, arg)  # 调用需要执行的函数,修改this值,并且传入参数
            timer = +new Date() # 重置初始时间
        }
    }
}
```

### 3.手写AJAX请求
```bash
const SERVER_URL = '/server';
let xhr = new XMLHttpRequest();
# 创建Http请求
xhr.open("GET", SERVER_URL, true);
# 设置状态监听函数
xhr.onreadystatechange = function () {
    if (this.readyState !== 4) return;
    # 请求成功时
    if (this.status === 200) {
        handle(this.response);
    } else {
        console.error(this.statusText);
    }
}
# 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
# 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
# 发送 Http 请求
xhr.send(null);
```

### 4.手写深拷贝
```bash
function fn(obj) {
    # 判断数据是否是复杂类型
    if (obj instanceof Object) {
        # 判断数据是否数组
        if (Array.isArray(obj)) {
            # 声明一个空数组来接收拷贝后的数据
            let result = [];
            obj.forEach(item => {
                # 需要递归深层遍历，否则复制的是地址
                resluit.puah(fn(item))
            })
            # 返回输出这个数组,数组拷贝完成
            return result
        } else {
            # 如果是对象，就声明一个空对象来接收拷贝后的数据
            let reslut = {}
            for (let k in obj) {
                # 使用递归深层遍历
                reslut[k] = fn(obj[k])
            }
            return result
        }
    }
    return obj
}
```

### 5.手写打乱数组顺序的方法
```bash
let arr = [1,2,3,4,5,6,7,8,9,10];
for (let i = 0; i < arr.length; i++) {
    const randomIndex = Math.round(Math.random() * (array.length - 1 - i)) + i;
    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]
}
```

### 6.用Promise实现图片的异步加载
```bash
let imageAsync = (url) => {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.src = url;
        img.onload = () => {
            console.log('图片请求成功, 此处进行通用操作')
            resolve(img)
        }
        img.οnerrοr=(err)=>{
            console.log(`失败，此处进行失败的通用操作`);
            reject(err);
        }
    })
}
```

## 二、算法基础
### 1.冒泡排序
每遍历一个元素，都会把之前的所有相邻的元素都两两比较一遍，即便是已经排序好的元素
思路：每轮循环将最大值排到末尾
```bash
let arr = [4, 1, 6, 8, 3, 2, 9, 7];
function bubbleSort (arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        for(let j = 0; j < arr.length - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            }
        }
    }
    return arr
}
```
### 2.选择排序
思路：选择排序，内层循环，每一圈选出最大的，然后放在后面
```bash
let arr = [4, 1, 6, 8, 3, 2, 9, 7];
function bubbleSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        let maxIndex = 0; # 每一圈选出一个最大的
        for (let j = 0; j < arr.length  - i; j++) {
            if (arr[maxIndex] < arr[j]) {
                maxIndex = j
            }
        }
        let temp = arr[maxIndex];
        arr[maxIndex] = arr[arr.length - i -1]
        arr[arr.length - i -1] = temp
    }
    return arr
}

console.log(bubbleSort(arr));
```

### 3.快速排序
```bash
let arr = [4, 1, 6, 8, 3, 2, 9, 7];
function bubbleSort(arr) {
    if (arr === null || arr.length === 0) return []
    let leader = arr[0];
    let right = []
    let left = []
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > leader) {
            right.push(arr[i])
        } else {
            left.push(arr[i])
        }
    }
    return [...bubbleSort(left), leader, ...bubbleSort(right)]
}

console.log(bubbleSort(arr));
```