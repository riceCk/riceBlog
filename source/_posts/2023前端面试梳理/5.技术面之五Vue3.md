---
title: 技术面之五Vue3
categories: 2023前端面试梳理
tags: 面试题
date: 2023-04-13 09:48:00
---

## vue3响应式相较于vue2具体哪些变化
1.数据拦截Object.defineProperty改变了Proxy + Object.defineProperty的拦截方式，其中
* ref:使用Object.defineProperty + Proxy 方式
* reactive: 使用Proxy

2.创建响应式数据的在语法层面有了改变：
* Vue2：通过Data来创建响应式数据
* Vue3：通过ref，reactive等方式来创建响应式数据

3.依赖收集上面的改变
* Vue2：Watcher + Dep
* Vue3: weackMap + Map + Set
* 这种实现方式可以实现更加细粒度的依赖追踪和更新控制 

## nextTikck实现原理
### 前瞻栗子
```bash
<template>
    <div>
        <div id="counterRef">计数：{{count}}</div>
        <button @click="increment">增加技术</button>
    </div>
</template>
<script setup>
import { ref } from 'vue'
const count = ref(0)
const increment = () => {
    for(let i = 1; i <= 1000; i++) {
        count.value = i
    }
}
</script>
```
思考🤔：点击按钮后，页面会渲染几次?
答案：只会渲染一次，同步代码中多次相应式数据做了修改，多次修改被毁**合并**为一次，之后根据最终的修改结果**异步**的去更新DOM。

思考🤔：倘若不合并，并且同步的去修改DOM，会有什么问题？
答案：数据一变就同步更新DOM，会导致频繁的重排重绘，非常损耗性能

思考🤔：异步更新会带来的问题？
答案：无法及时获取到更新后的DOM值
原因：因为获取的DOM数据是同步代码，DOM的更新是异步代码，同步代码会现优先于异步代码
解决方案：将获取的DOM数据的同步任务包装成一个微任务，浏览器在完成一次渲染后，就会立即执行微任务
**当前我们自己的解决方案**
```bash
const increment = () => {
    # 比如当前最新数据是 2
    count.vlaue++
    console.log('同步通过Dom拿textContent数据：'， coutnerRef.value.textContent) // 1
    Promise.resolve().then(() => {
        console.log('最新的数据：', count.value) // 2
        console.log('异步通过Dom拿textContent数据：'， coutnerRef.value.textContent) // 2
    })
}
```

**nextTick帮我们做了就是上面的事情，将一个任务包装成一个微任务**
nextTick 返回的是一个Promise
```bash
const increment = () => {
    # 比如当前最新数据是 2
    count.vlaue++
    console.log('同步通过Dom拿textContent数据：'， coutnerRef.value.textContent) // 1
    nextTick(() => {
        console.log('最新的数据：', count.value) // 2
        console.log('异步通过Dom拿textContent数据：'， coutnerRef.value.textContent) // 2
    })
    # 或者下面写法
    await nextTick()
    console.log('最新的数据：', count.value) // 2
    console.log('异步通过Dom拿textContent数据：'， coutnerRef.value.textContent) // 2
}
```