---
title: 技术面之五Vue
categories: 2023前端面试梳理
tags: 面试题
date: 2023-04-26 09:48:00
---

## vue 面试题汇总

### 1.MVC和MVVM区别
MVC 全名 Model View Controller，是模型（model）- 视图（view）-控制器（controller）的缩写，一种软件设计典范
* （1）Model 模型：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据
* （2）View 视图：是应用程序中处理数据显示部分。通常视图是依据模型数据创建的
* （3）Controller 控制器：是应用程序中处理用户交互的部分。通常控制器负责从事图读取数据，控制用户输入。冰箱模型发送数据

MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话就是在Controller里面吧Model的数据赋值给View。

> **MVVM**
MVVM新增VM类
> ViewModel层：做了两件事达到了数据的双向绑定，一是将【模型】转成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二将【视图】转化成【模型】，即将所看到多页面转化成后端数据，实现DOM事件监听
> MVVM和MVC最大的区别就是，它实现了View和Model的自动同步，也就是当Model的属性改变是，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后改属性对应View层显示自动改变（对应Vue数据驱动的思想）
> 整体来来，MVVM比MVC精简了很多，因为MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性
> 严格来说MVVM要求View不能和Model直接通行，而Vue提供了$ref这个属性，让Model可以直接操作View，违反了这一规定，所以Vue没有完全遵循MVVM。

### 2.Vue是如何实现响应式数据
> **Vue2:**
> Object.definPropert重写定义data中所有属性，添加了访问器属性，当读取data中数据是自动调用get方法，当修改data中数据时，自动调用set方法，监测到数据的变化。
> 数组变化方法pop，push，shift，unshift，splice、sort，reverse这七种，只要这些方法执行改了数组内容

> **Vue3：**
> 改用了proxy，可以直接监听数组变化

### 3.Vue的优点
**轻量级框架：** 只关注视图层。是一个构建数据的视图集合，大小只在几十kb
**简单易学：** 国人开发，中文文档，不存在语言障碍，易于学习和理解
**双向数据绑定：** 保存了angular的特点，在数据操作方便更加简单；
**组件化：** 保存了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势。
**视图，数据，结构分离：** 使数据的更改变成简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；

### 4.为什么vue组件中data必须是一个函数
对象为引用类型，当复用组件，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件的data会被修改，而使用返回对象的函数，由于每次返回都是一个新对象（Object的实例），引用地址不同，不会出现这个问题

### 5.父子组件生命周期调用顺序
渲染循序：先父后子，完成循序：先子后父
更新循序：父更新导致子更新，子更新完成后父
销毁循序，先父后子，完成顺序：先子后父
父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
### 6.diff算法
> 时间复杂度：个树的完全diff算法是一个事件复杂度为o（n * 3），vue进行优化转化成o（n）
> Diff算法，当data发生改变，会根据新的数据生成一个新的虚拟dom，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法，会找到不同地方，只会渲染不同地方，总的太说就是减少dom，重绘和回流
> **理解：**
>（1）最小量更新，key很重要。这个可以是这个节点唯一标识，告诉diff算法，在更改前后他们是同一个节点
* 扩展v-for为什么要有key，没有key会暴力复用，举个例子的话说一个比如移动字节或者增加节点（修改DOM），加key只会移动减少操作DOM。

> （2）只有同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的。插入新的
> （3）只进行同层比较，不会进行跨层比较

### 7.v-for 为什么要加key
> 如果不使用key，vue会使用一个最大限制减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。Key是为了Vue中vnode的唯一标记，通过key，diff操作可以更准确，更快速
> * **更准确：**因为带key就不是就地复用了，在someNode函数a.key === b.key对比中可以避免就地复用的情况，所以更加准确
> * **更快速：**利用key的唯一性生成map对象来获取对应节点，比遍历方式更快

### 8.Vue 的路由实现
* （1）解释hash模式和history模式的实现原理
* （2）说一下$route与$router的区别
* （3）vueRouter有几种导航守卫
* （4）解释下vueRouter的完整的导航解析流程是什么

#### (1) 解释hash模式和history模式的实现原理
> hash值变化，不会导致浏览器向服务器发起请求，浏览器不发请求，就不会刷新页面；通过hashchange事件，可以知道hash发生了那些变化，让后根据hash变化来实现更新页面部分内容的操作。
> history模式的实现，主要是html5标注两个api，pushState和replaceState，这两个api可以在改变Url，但是不会发送请求，这样就可以监听url变化来实现更新页面部分内容的操作
> **两种模式的区别：**
* 首先Url的展示上，hash模式有#
* 刷新页面时，hash模式可以正常加载到hash值对应的页面，而history没有做处理的话，会返回404，一般需要后端将页面配置重定向到首页路由
* 在兼容方面hash可以支持低版本浏览和el

#### (2)$router 与 $route 的区别
> **$route对象表示当前路由信息，包含当前URL解析得到的信息，包含当前的路径，参数，query对象**
> * $route.path: 字符串，当前路由路径
> * $route.params 动态片段和全匹配片段
> * $router.query url查询参数
> * $rouer.name 路径命

> **$router对象是全局路由的实例，是router构造方法的实例**
> **$router对象常用的方法：**
> push: 向history技术栈添加新的记录
> go: 页面路由跳转前进或后退
> replace: 替换当前的页面，不会向history栈添加一个新的记录

#### （3）vueRouter有哪些导航守卫
* 全局前置/钩子： beforeEach、afterEcah
* 路由独享守卫；beforeEnter
* 组件内守卫：beforRouteEnter、beforeRouterUpdata、beforeRouteLeave

#### (4) vueRouter 的完整导航解析流程是什么
* 导航被触发
* 在失活的组件里调用离开守卫
* 调用全局的beforeEach守卫
* 在重用的组件里调用beforeRouterUpdate守卫
* 在路由配置里调用beforEnter
* 解析异步路由组件
* 在被激活的组件里调用beforeRouteEnter
* 调用全局的beforeResolve守卫
* 导航被确认
* 调用全局的afterEach钩子
* 触发DOM更新
* 用创建好的实例调用beforRouteEnter守卫的next的回调函数


### 9.vuex的个人理解
Vuex是专门为vue提供的全局状态管理系统，用户多组件数据共享，数据等
主要包括以下几个模块
* state：定义了应用状态的数据结构，可以这里设置默认的初始化状态
* geeter：允许组件从store中获取数据，mapGetter辅助函数仅仅将store中的geeter映射到全局计算属性
* mutation：唯一更改story中状态的方法，必须是同步函数
* action：用户提交mutations。而不是直接更改状态，可以包含异步
* module：允许将单一的store拆分多个store且同时保存单一状态树中

### 10.keep-alive使用场景和原理
> Keep-alive是Vue内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载
> * （1）常用的两个属性include/exclude，允许组件有条件的进行缓存
> * （2）两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态

### 11、Vue.extend 作用和原理
Vue.extend使用基础Vue构造器，创建一个“子类”。参数是一个包含组件选项的对象
其实就是一个子类构造器是Vue组件的核心api实现思路就是使用原型继承的方法返回了Vue的子类并且利用mergeOptions把传入组件的options和父类的options进行合并

### 12.vue组件通讯
* （1）props/$emit+v-on：通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息
* （2）ref 与 $parent / $children 适用 父子组件通信
* （3）Vuex：全局数据管理库，可以通过vuex管理全局的数据流
* （4）$atters/$listeners：vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信
* （5）provide/inject：以允许一个祖父组件想其他所有子孙后代诸如一个依赖，不论组件层级有多深，并在起上下游关系成立的时间里始终生效，这成为跨组件通讯的基础

### 13、computed和watch有什么区别
Computed：
（1）computed是计算属性，也就是计算值，它更多用于计算值的场景
（2）computed具有缓存性，computed的值在getter执行后是会缓存，只有依赖的属性值改变之后，下一次获取computed的值时才会重写调用对应的getter来计算
（3）computed适用于计算比较消耗性能的计算场景

Watch：
（1）更多的是【观察】的作用，类似某些数据的监听回调
（2）无缓存性，页面重新渲染时值不变化也会执行

### 14、虚拟DOM的优劣如何
虚拟DOM，其实就是用对象的方式取代真实的DOM操作，把真实的DOM操作放在内存中，在内存中的对象里做模拟操作，当页面打开浏览器会解析HTML元素，构建一个DOM树，将状态全部保存起来，在内存当中模拟我们真实的DOM操作，操作完后会生成一颗DOM树，两个DOM树进行比较，根据diff算法比较两个DOM树不同的地方。只会渲染一次不同地方
（个人理解）虚拟dom他不是正式DOM，是根据模板生成的js对象，根据这个js对象再去生成真实的dom对象

优点：
（1）保证性能下限：虚拟DOM可以经过diff找出最小差异，然后批量进行patch，这种操作虽然比不上手动优化，但是比起粗暴的DOM操作性能要好很多，
（2）无需手动操作DOM：蓄力DOM的diff和patch都是在一次性更新中自动进行的，我们无需手动操作DOM，极大提高开发效率
（3）跨平台性：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以镜像更方便的跨平台操作，比如服务器渲染、移动端开发
缺点：
（1）无法进行极致优化：在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致有阿虎，比如VScode采用直接手动操作DOM的方式进行极端的性能优化

### 15、虚拟DOM实现原理
* （1）虚拟DOM本质上是JavaScript对象，是对实际DOM的抽象
* （2）状态变更时，记录新树和旧树的差异
* （3）最后把差异更新到真正dom中

### 16、$nextTick 是什么？
Vue实现响应式并不是在数据发生后立即更新的DOM，使用$nexTick是在下次DOM更新循环结束之后立即执行延迟回调，在修改数据之后使用，则可以在回调中获取更新后的DOM
优先于Promise.then方法，是微任务，可以避免多一次队列，进而少一次ui渲染

### 17、Vue模板编译原理
Vue的编译过程就是讲template转化为render函数过程，分为三步
第一步：讲模板字符串转化成elment ASTS解析器
第二步：是对ast镜像静态节点标记，主要用来做虚拟DOM的渲染优化
第三步：使用element AST生成render函数代码字符串

### 18、Vue修饰符有哪些
> **事件修饰符**
> * （1）.stop阻止事件继续传播
> * （2）.prevent阻止标签默认行为
> * （3）.once事件将只会触发一次
> * （4）.passive 告诉浏览器你不想阻止事件的默认行为

> **v-model修饰器**
> * （1）.number自动将用户输入值转化成数值类型
> * （2）.trim自动过滤用户输入的收尾空格

> **键盘事件的修饰符**
> * （1）.enter 
> * （2）.tab
> * （3）.delete（捕获删除和退格键）
> * （4）.esc
> * （5）up、down、left、right

### 19、Vue性能优化
> **编码优化：**
> * （1）事件代理
> * （2）keep-alive
> * （3）拆分组件
> * （4）key保证唯一性
> * （5）路由懒加载、异步组件
> * （6）防抖节流

> **Vue加载性能优化**
> * （1）第三方模块按需引入 （babel-plugin-component）
> * （2）图片懒加载

### 20、vue3和vue2区别
* （1）双向数据绑定区别，vue3采用的 proxy
* （2）setup函数
* （3）默认懒加载

### 21、vue生命周期
* （1）beforeCreate（）创建前，这时候data中数据，还未定义，所以不能使用
* （2）create（）创建后，最早开始使用data和methods中数据的钩子函数
* （3）beforeMount（）挂载前，指令时已解析完成内存中dom树，但是尚未挂载到页面中，页面还是旧的
* （4）mounted（）挂载后，dom已经渲染完成，此时页面和内存都是最新的数据，最早可以操作dom元素钩子函数
* （5）beforeUpdate（）更新前，当视图层的数据发生改变会执行这个钩子，内存更新，但是dom节点还未更新，数据没有与页面同步
* （6）updated（）更新后，数据更新完成以后出发的方法，dom节点已经更新
* （7）beforeDestroy（）即将销毁data和methods中数据此时还是可以使用的，可以做一些释放内存的操作
* （8）detroyed（）销毁完毕  组件已经全部销毁，vue实例已经被销毁，vue中任意数据都不可用

### 22、v-for和v-if的优先级
v-for的优先级比v-if要高。所以vue会先进行遍历，然后再进行条件判断，这样在条件为假的时候会造成不必要的性能浪费。

### 23、自定义指令
> 全局的：vue.directive{"", {}} 
> 局部：directives:{指令名：{钩子函数}}
> Bind：只调用一次，指令第一次绑定元素时调用，这里可以进行一次性的初始化设置
> Inserted：被绑定元素插入父节点调用（仅保证父节点存在，但不一定已被插入文档）
> Update：所在组件VNode更新是调用，但是可能发生在其子VNode更新前。
> **参数：**
> * El：指令所绑定的元素
> * Binding：一个对象包含一下
> * Name：指令名，不包括v-前缀
> * Value：指令绑定值

### 24、什么是mixin
Mixin是我们能够为vue组件编写插拔和可重用功能，mixin项目变更复杂的时候，多个组件间有重复逻辑可以用到mixin，在执行时优化组件自己的

### 25、单页面应用和多页面应用区别以及有优缺点：
> **单页面：只有一个html页面，跳转方式是组件之间切换**
> * 优点：跳转流畅，组件化开发、组件复用、开发便捷
> * 缺点：首屏加载过慢

> **多页面：有多个页面，跳转方式是页面直接跳转**
> * 优点：首屏加载快
> * 缺点：跳转速度慢

### 26、vue首屏加载优化
> （1）对第三方js库进行优化，分离打包，或者放在cdn服务器上
> （2）使用路由懒加载
> （3）图片资源压缩，icon资源进行雪碧图、
> （4）开启gizp压缩 npm i compression-webpack-plugin -D
> （5）代码层面优化
* 合理使用v-if和v-show
* 合理使用watch和computed
* 使用v-for必须添加key，做好唯一标识id，避免v-for和v-if同时使用
* 定时器销毁，

### 27、vue的整个实现流程
* 第一步：解析模板成render函数
* 第二步：响应式开始监听
* 第三步：首次渲染，显示页面，且绑定依赖
* 第四步：data属性变换，触发render

#### 第一步：解析模板成render函数
* with的用法
* 模板中的所有信息都被render函数包含
* 模板中用到的data中的属性，都变成js变量 
* 模板中的v-model,v-for,v-on都变成了js逻辑
* render函数返回的vnode

#### 第二步：响应式开始监听
* Object.defineProperty
* 将data的属性代理到vm上

#### 第三步：首次渲染，显示页面，且绑定依赖
* 初次渲染，执行updateComponent，执行vm._render()
* 执行render函数，会访问到vm.list和vm.title
* 会被响应式的get方法监听到
* 执行updateComponent，会走到vdom的patch方法
* patch将vnode渲染DOM，初次渲染完成

#### 第四步：data属性变化，触发render

### 28、说说你对SPA单页面的理解
仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。
**优点：**
> * 用户体验好、快，内容的改变不需要重新加载整个页面，避免不需要的跳转和重复渲染
> * 基于上面一点，SPA相对服务器压力小
> * 前后端责任分离，架构清晰，前端进行交互逻辑，后端负责数据处理

**缺点：**
> * 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
> * 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
> * SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

### 29、你有对Vue项目进行哪些优化
参考本文作者的另一篇文章[《 Vue 项目性能优化 — 实践指南 》](https://juejin.cn/post/6844903913410314247)，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。
**(1)代码层面的优化**
> * v-if 和 v-show 区分使用场景
> * computed 和 watch 区分使用场景
> * v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
> * 长列表性能优化
> * 事件的销毁
> * 图片资源懒加载
> * 路由懒加载
> * 第三方插件的按需引入
> * 优化无限列表性能
> * 服务端渲染 SSR or 预渲染

**（2）Webpack 层面的优化**
> * Webpack 对图片进行压缩
> * 减少 ES6 转为 ES5 的冗余代码
> * 提取公共代码
> * 模板预编译
> * 提取组件的 CSS
> * 优化 SourceMap
> * 构建结果输出分析
> * Vue 项目的编译优化

**（3）基础的 Web 技术的优化**
> * 开启 gzip 压缩
> * 浏览器缓存
> * CDN 的使用
> * 使用 Chrome Performance 查找性能瓶颈