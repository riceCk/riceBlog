---
title: 前端模块化
categories: 前端模块化
date: 2018-08-9 21:30:00
---
# 一、模块化的实现
* 函数
* 对象写法
* 匿名函数、返回对象
* 依赖传入实参

## 1、函数
```bash
function add(a,b){
  return a + b;
}
function a (a){
  console.log(a);
}
```
## 2、对象
```bash
var ptt = {
  len: 3,
  init: function(){},
  ctrateDom: function(){},
}
```
## 3、匿名函数、返回对象
```bash
#私有化变量
(function(){
  var len = 3;
  function add(a, b){
    return a + b;
  }
  return {
    add: add
  }
})()
```
## 4、依赖
```bash
(function(a, b){

})(window, function(window){
  window.jQuery = jQuery;
  function jQuery(){}
})
```
# 二、CommonJs规范
根CommonJs规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量
## CommonJs思想
CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口
```bash
# index.js
var module = require('module.js');
moudule.add('hell');

#module.js
module.exports = {
  aa:function(str){
    console.log(str)
  }
}
```
## CommonJs缺点
* 浏览器不兼容CommonJs，原因是浏览器缺少module、exports、require、global四个环境变量。如要使用需要工具转换
* CommonJS采用同步加载不同模块文件，适用于服务器端的。因为模块文件都存放在服务器的各个硬盘上，读取加载时间快，适合服务器端，不适应浏览器。

# 三、AMD
## 下载require.js包
```bash
# main.js中 导入处理
#统一路径 
require.config({  
	baseUrl: './js/tool',
	paths: {
		'jquery': 'jquery',
		'math': 'math'
	}
})

require(['jquery', 'math'], function($, math){
	#模块导入
	console.log($());  #继续实现功能
	console.log(math.add(1, 2));
})

# math.js 子方法
define(['myLib'], function(myLib){  
 #模块定义 + 模块导入
    console.log(myLib.a);   #获取模块myLib值
    function add(a, b){
        return a + b;
    }
    return {
        add : add
    }
})

# myLib.js 子方法
define(function(){  //定义模块
    return {
        a: 123
    }
})

```
# 四、webpack自动化打包工具的配置
## webpack 命令行配置
```bash
#初始化
npm init
# 在本地文件下载webpack定义开发环境
npm install webpack --save-dev
# 下载webpack支架，webpack4之后需要单独下载
cnpm install webpack-cli -g
```
## 创建入口文件
webpack4之后到这边必须创建一个src文件下index.js入口文件，webpack3之前没问题，基于4之后就必须创建否则报错，之后运行webpack命令会自动创建一个dist出口文件

## 四个核心模块及概念
* 入口 entry
入口起点指 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的

* 输出 output
告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。

* 依赖 loader
loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。

* 插件 plugins
插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

## 模块化
```bash
# 主入口文件中
var demo = require('./demo.js');
demo.add(22, 33);

#模块化子组件
module.exports = {
  add: function(a, b){
    console.log(a + b);
  }
}
```
## 图片的打包
### webpack.config.js的配置
```bash
module.exports = {
  #入口配置
  entry:{
    demo: './src/demo.js',
    index: './src/index.js'
  },
  #输出配置
  output: {
    path: __dirname + '/out',
    filename: '[name].bundle.js',
    publicPath: './out'
  },
  module: {
    rules: [
      {test:/.jpg$/,use:['url-loader?limit=10?&name=/[name].[ext]']}
    ]
  },
  #开发环境
  mode: 'development'
}
```
### 下载的依赖
```bash
npm install url-loader --save-dev
npm install file-loader --save-dev
```
### 入口文件的配置
```bash
# 入口文件 index.js
var img = new Image();
img.src = require('./img/7.jpg');
document.body.appendChild(img);
```
# 五、浅谈MVC、MVP及MVVM
## MVC
![MVP](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/MVC.jpg)
* 控制器负责管理视图和模型；
* 视图负责展示模型中的内容；

## MVP
MVP框架模型是MVC的一种变种，很多框架都自称遵循MVC框架模式，但是他们实际上却实现了MVP模式，`M`则是**model**模型，`M`则是**View**视图，`p`则是**Presenter**，模型和视图彼此一无所知，通过Presenter进行沟通。
![MVP](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/MVP.jpg)
* 当视图接收到来自用户事件时，会将事件转交给Presenter进行处理；
* 被动的视图向外界暴露接口，当需要更新视图时Presenter通过视图暴露的接口更新视图的内容
* Presenter负责对模型进行操作和更新，在需要时取出其中存储的信息；
* 当模型改变时，可以将改变的信息发送给观察者Presenter；

## MVVM:视图模式 
Model-View-ViewModel，他由三个部分组成Model、View和ViewModel；其中视图模型（ViewModel）其实就是PM模式中的展示模型，在MVVM中叫做视图模型，除了我们非常属性的Model、View和ViewModel这三个部分，在MVVM的实现中，还引入了**隐私**一个Binder层，而声明式的数据和命令的绑定在MVVM模式中就通过它完成。

