---
title: 7.TS的类和泛类
categories: TypeScript
tags: TypeScript
date: 2020-05-14 19:36:00
---

# TS中类
> 面向对象思想
基础部分，学习类的时候，仅讨论新增的语法部分

## 属性
使用属性列表描述类中的属性

```bash
class User {
  readonly id: number # 属性修饰只读
  name: string
  age: number
  gender: '男' | '女' = '男' # 设置默认值
  pid?: string # 可选
  private publishNumber: number = 3 # 私有 每天最多数量
  private curNumber: number = 0 # 私有 当前的数量
  constructor (name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

const u = new User('aa', 2);
```

### 属性的初始化检查
``strictPropertyInitialization: true``
属性的初始化位置：
1.构造函数中
2.属性的默认赋值
### 属性可选的
```bash
class User {
  pid?: string # 可选
}
```
### 属性可以修饰为只读的
```bash
class User {
  readonly id: number # 属性修饰只读
}
```
### 使用访问修饰符
访问的修饰符可以控制类中的某个成员的访问权限
- public: 默认的访问修饰符，公开的，所有的代码均可访问
- private：私有的，只有在类中可以访问

```bash
class User {
  private publishNumber: number = 3 # 每天最多数量
  private curNumber: number = 0 # 当前的数量
  publish(title: string) {
    if (this.curNumber < this.publishNumber) {
      console.log('发布一篇文章' + title)
      this.curNumber++
    } else {
      console.log('已上线')
    }
  }
}

const u = new User();
u.publish('12312')
u.publish('12312')
u.publish('12312')
u.publish('12312')
```

### 属性简写
如果某个属性，通过构造函数的参数传递，并且不做任何处理的赋值给该属性。可以进行简写
```bash
class User {
  constructor (public name: string, public age: number) {
    this.name = name;
    this.age = age;
  }
}
const u = new User('aa', 2);
```

### 访问器

作用：用于控制属性的读取和赋值 
```bash
class User {
  constructor (public name: string, public _age: number) {
    this.id = Math.random()
    this.name = name;
  }
  set age (value: number) {
    if (value < 0) {
      this._age = 0
    }
    this._age = value
  }
  get age () {
    return this._age
  }
}

const u = new cUser('aa', 2);
u.age = 2
console.log(u.age)
```

## 发牌功能，添加洗牌和发牌
**index.ts**入口
```bash
import {Deck} from './deck'

const deck = new Deck
deck.shuffle()
console.log('=======洗牌之后========')
deck.print()
const reult = deck.publish();
console.log('=======发牌之后========’')

reult.player1.print();
console.log('======1=======')

reult.player2.print();
console.log('======2=======')

reult.player3.print();
console.log('======3=======')
```

**deck.ts**创建牌的类
```bash
import { Card, Joker, NoramlCard } from "./types";
import { Color, Mark } from './enums'

interface PublishResult {
  player1: Deck,
  player2: Deck,
  player3: Deck,
  left: Deck,
}

export class Deck {
  private cards: Card[] = []
  constructor(cards?: Card[]) {
    if (cards) {
      this.cards = cards
    } else {
      this.init()
    }
  }
  # 初始化整理牌
  private init() {
    const maeks = Object.values(Mark);
    const colors = Object.values(Color);
    for (const m of maeks) {
      for (const c of colors) {
        this.cards.push(<Card>{ # 类型断言，强制定义成功Card类型
          color: c,
          mark: m,
          getString() {
            return this.color + this.mark
          }
        })
      }
    }
    let joker: Joker = {
      type: "small",
      getString() {
        return 'jo'
      }
    }
    this.cards.push(joker)
    joker = {
      type: 'big',
      getString() {
        return "JO"
      }
    }
    this.cards.push(joker)
  }
  # 打印牌
  print() {
    this.cards.forEach(item => {
      console.log(item.getString())
    })
  }
  # 洗牌
  shuffle() {
    for (let i = 0; i <this.cards.length; i++) {
      const targetIndex = this.getRandom(0, this.cards.length);
      const temp = this.cards[i]
      this.cards[i] = this.cards[targetIndex]
      this.cards[targetIndex] = temp
    }
  }
  # 发牌后，得到结果有是个4card[]
  publish (): PublishResult {
    let player1: Deck, player2: Deck, player3: Deck, left: Deck;
    player1 = this.takeCards(17);
    player2 = this.takeCards(17);
    player3 = this.takeCards(17);
    left = this.takeCards(3);
    return {player1, player2, player3, left}
  }
  private takeCards (n: number):Deck {
    const cards: Card[] = []
    for (let i = 0; i < n; i++) {
      cards.push(this.cards.shift() as Card);
    }
    return new Deck(cards)
  }
  /**
   * 无法取到最大值
   * @param min 
   * @param max 
   */
  private getRandom(min: number, max: number) {
    const dec = max - min
    return Math.floor(Math.random() * dec + min)
  }
}
```

**types.ts**定义三种接口
```bash
import {Color, Mark} from './enums'

export interface Card {
  getString(): string
}

export interface NoramlCard extends Card {
  color: Color,
  mark: Mark
}

export interface Joker extends Card {
  type: 'big' | 'small'
}
```

**定义两种枚举类型**
```bash
export enum Color {
  heart = "♥",
  spade = "♠",
  club = "♣",
  diamond = "♦"
}

export enum Mark {
  A = "A",
  two = '2',
  three = '3',
  four = '4',
  five = '5',
  six = '6',
  seven = '7',
  eight = '8',
  nine = '9',
  ten = '10',
  eleven = 'J',
  twelve = 'Q',
  king = 'k'
}
```

# 泛类
有事，书写某个函数时，会丢失一些类型信息（多个位置的类型应该保持一致或者关联的信息）
下面返回的数据就是any数组，丢失传入的number[]信息
```bash
function take(arr: any[], n: number): any[] {
  if (n >= arr.length) {
    return arr;
  }
  let newArr: any[] = [];
  newArr = arr.slice(0, n)
  return newArr
}
const newArr = take([1, 2, 3, 4, 5, 6, 8], 3)
console.log(newArr)
```

泛型：是指附属于函数、类、接口、类型别名之上的类型
泛型相当于一个类型变量，在定义时，无法预先知道具体的类型，可以用该变量来替代，只有到调用时，才能确定他的类型

很多时候，TS会智能的根据传递的参数`推导`出泛型的具体类型

如果无法完成推导，并且又没有传递具体的类型，默认为`空对象`

泛型可以设置`默认值`

## 在函数中使用泛型
在函数名之后写上`<泛型名称>`
```bash
# 可以传默认值，如果不传默认number
function take<T = number>(arr: T[], n: number): T[] {
  if (n >= arr.length) {
    return arr;
  }
  let newArr: T[] = [];
  newArr = arr.slice(0, n)
  return newArr
}
# 这边的<number>可以去掉，也能推导出来
let arr = take<number>([1, 2, 3, 4, 5, 6], 3)
```

## 如何在类型别名、接口、类中使用泛型
直接在名称后面上`<泛型名称>`
```bash
type callback<T> = (n: T, i:number) => boolean

function filter<T>(arr: T[], callback: callback<T>): T[] {
  const newArr: T[] = [];
  arr.forEach((n, i) => {
    if (callback(n, i)) {
      newArr.push(n)
    }
  })
  return newArr
}
const arr = [3, 4, 5, 23, 11]
filter<number>(arr, n => n % 2 !== 0)
```
**类的泛型实现**
```bash
export class ArrayHelper<T> {
  constructor (private arr: T[]) {}

  take(n: number): T[] {
    if (n >= this.arr.length) {
      return this.arr;
    }
    const newArr: T[] = this.arr.splice(0, n)
    return newArr
  }
  
  shffle() {
    for(let i = 0; i < this.arr.length; i++) {
      const targetIndex = this.getRandom(0, arr.length);
      const temp = this.arr[i];
      this.arr[i] = this.arr[targetIndex];
      this.arr[targetIndex] = temp
    }
  }

  private getRandom(min: number, max: number) {
    const dec = max - min
    return Math.floor(Math.random() * dec + min)
  }
}
```

## 泛型约束 
泛型约束，用于实现泛型取值，利用继承方式`extends`
```bash
interface hasNameProperty {
  name: string
}

/**
 * 将某个对象的name属性的每个单词首字母大写，
 * 然后将对象返回
 */
 # 通过继承进行限制
function nameToUpperCase<T extends hasNameProperty> (obj: T): T {
  obj.name = obj.name
  .split(" ")
  .map(s => s[0].toUpperCase + s.substr(1))
  .join(" ");
  return obj
}

const o = {
  name: 'charles',
  age: 22,
  gender: '男'
}
 
const newO = nameToUpperCase(o);
console.log(newO)
```

## 多泛型
实现多种泛型场景
```bash
# 将两个数组进行混合[1, 2, 3] ["a", "b", "c"]
function mixinArray<T,K>(arr1: T[], arr2: K[]): (T | K) [] {
  return Object.assign(arr1, arr2)
}
const newArray = mixinArray([1, 2, 3, 4], ["1", "3", "4", "8"])
```

# 自定义字典练习
开发一个字典类（dictionary），字典中会保持键值对的数据

键值对数据的特点：
- 键（key）可以是任何类型，但是不允许重复
- 值（value）可以是任何类型
- 每个键对应一个值
- 所有的键类型相同，所有的值类型相同

字典类中对键值对数据的操作：
- 按照键，删除对应的键值对
- 循环每一个键值对
- 得到当前键值对的数据量
- 判断某个键是否存在
- 重新设置某个键对应的值，如果不存在，则添加

```bash
export type Callback<T, U> = (key: T, val: U) => void;

export class Dictionary<K, V> {
  private keys: K[] = [];
  private vals: V[] = [];
  private _size: number = 0;

  get size () {
    return this._size
  }
  
  set (key: K, val: V) {
    const i = this.keys.indexOf(key)
    if (i < 0) {
      this.keys.push(key);
      this.vals.push(val)
      this._size++
    } else {
      this.vals[i] = val
    }
  }
  forEach(callback: Callback<K, V>) {
    this.keys.forEach((k, i) => {
      const v = this.vals[i]
      callback(k, v);
    })
  }
  has(key: K) {
    return this.keys.includes(key);
  }
  delete(key: K) {
    let index = this.keys.indexOf(key);
    if (index === -1) {
      return
    }
    this.vals.splice(index, 1);
    this.keys.splice(index, 1);
    this._size-- 
  }
}
```