---
title: 4.TS-扩展类型_枚举
categories: TypeScript
tags: TypeScript
date: 2020-05-06 19:36:00
---

# 扩展类型-枚举
> 扩展类型：类型别名、枚举、接口、类

枚举通常用于约束某个变量的取值范围。
字面量和联合类型配合使用，也可以达到同样的目标。

# 字面量类型的问题
- 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题

```bash
type Gender = '男' | '女'
let gender: Gender;
gender = '男'
gender = '女'
function searchUsers(g: Gender) {}
```

- 逻辑名称和真实的值产生了混淆，会导致当修改真实值的时候，产生大量的修改
- 字面量类型不会进入编译结果

# 枚举
枚举会出现在编译结果中，编译结果中表现为对象
## 枚举的规则：
- 枚举的字段值可以是字符串或数字
- 数字枚举的值会自动自增

```bash
enum Level {
  level1,  # 不赋值初始值0，下面默认递增
  level2, 
  level3, 
}
```
- 被数字枚举约束的变量，可以直接赋值为数字

```bash
enum Level {
  level1, 
  level2, 
  level3, 
}
# 没问题
let l: Level = Level.level1
l = 1

enum Gender {
  male = "男",
  femal = '女'
}
let gender: Gender;
gender = Gender.male
gender = '女' # 报错不行
```
- 数字枚举的编译结果 和 字符串枚举有茶余

## 如何定义一个枚举
```bash
enum 枚举名 {
  枚举字段1 = 值1,
  枚举字段2 = 值2,
  ...
}
```
举个栗子
```bash
enum Gender {
  male = "男",
  femal = '女'
}
let gender: Gender;
gender = Gender.male
gender = Gender.femal
function printGenders () {
  const vals = Object.values(Gender);
  vals.forEach(v => console.log(v));
}
printGenders();
```

## 最佳实践
- 尽量不要在一个枚举中即出现字符串字段，又出现数字字段
- 使用枚举时，尽量使用枚举字段的名称，而不使用真实的值

枚举打印扑克牌
```bash
type Deck = NormalCard[]
enum Color {
  heart = "♥",
  spade = "♠",
  club = "♣",
  diamond = "♦"
}

enum Mark {
  A = "A",
  two = '2',
  three = '3',
  four = '4',
  five = '5',
  six = '6',
  seven = '7',
  eight = '8',
  nine = '9',
  ten = '10',
  eleven = 'J',
  twelve = 'Q',
  king = 'k'
}

type NormalCard = {
  color: Color,
  mark: Mark,
}

function createDeck (): Deck {
  const deck: Deck = []
  const maeks = Object.values(Mark);
  const colors = Object.values(Color);
  for (const m of maeks) {
    for (const c of colors) {
      deck.push({
        color: c,
        mark: m
      })
    }
  }
  return deck
}
function printDeck (deck: Deck) {
  deck.forEach(item => {
    console.log(`${item.color}: ${item.mark}`)
  })
}
printDeck(createDeck())
```

## 扩展知识：位枚举（枚举的位运算）
针对的数字枚举
为运算：两个数字换算成二进制进行的运算

```bash
enum Permission {
  Read = 1,   // 0001
  Write = 2,  // 0010
  Create = 4, // 0100
  Delete = 8, // 1000
}

# 使用或运算
# 0001
# 或 |
# 0010
# 0011
let p = Permission.Read | Permission.Write

# 2.如何判断是否拥有某个权限
# 0011
# 且 &
# 0010
# 0010
function hasPermission (target: Permission, per: Permission) {
  return (target & per) === per
}

# 判断变量p是否拥有可读的权限
hasPermission(p, Permission.Read);

# 3.如何删除某个权限
# 0011
# 异或
# 0010
# 0001 相同取零不同取1
p = p ^ Permission.Write

hasPermission(p, Permission.Read);
```