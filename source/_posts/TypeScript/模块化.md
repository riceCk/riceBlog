---
title: 5.TS-模块化
categories: TypeScript
tags: TypeScript
date: 2020-05-08 19:36:00
---
# 模块化
相关配置

|配置名称|含义|
|:------:|:-----:|
|module|设置编译结果中使用的模块化标准|
|moduleResolution|设置间隙模块的模式|
|noImpliciuUseStrict|编译结果中不包含"use strict"|
|removeComments|编译结果移除注释|
|noEmitOnError|错误时不生成编译结果|
|esModuleInterop|启用es模块化交互非es模块导出|

> 前端领域中的模块化标准：ES6、commonj 、amd、umd、system、esnext

> TS中如何书写模块化语句
> 编译结果？？

# TS中如何书写模块化语句
TS中，导入和导出模块，统一使用ES6的模块化标准
**myModules.ts**导出
```bash
export const name = 'charles'

export function sum(a: number, b: number) {
  return a + b;
}

export default {
  name: 'charles'
}
```
**index.ts**导入
```bash
import {name, sum} from './myModule';

console.log(name, sum)
```

# 编译结果中的模块化
可配置

TS中的模块化在编译结果中：
- 如果编译结果的模块化标准是es6：没有区别
- 如果编译结果的模块化标准是commonjs，导出的声明会变成exports的属性，默认的导出会变成exports的defalut属性；

# 解决modules中默认导入错误
导出fs模块
```bash
import * as fa from 'fs'
fs.readFilesSync('./')
```

# 如何在TS中书写commonjs模块化代码
TS导出语法
```bash
export = {}
```
**myModule.ts**导出
```bash
# 这种方式可以实现导出但是无法实现类型检查
module.exports = {
  name: "kevin",
  sum(a: number, b: number) {
    return a + b;
  }
}
```
```bash
# TS语法，具有类型检查
export = {
  name: "kevin",
  sum(a: number, b: number) {
    return a + b;
  }
}
```
**index.ts**导入
TS语法导入
```bash
import 声明 = require('路径')
```
```bash
# 这种方式可以导出但是没法进行类型检查 
const {name, sum} = require('./myModule');
```
```bash
import myModule = reuqire('./myModule');
```

# 模块化解析
模块解析：应该从什么位置寻找模块
TS中，有两种模块解析策略

- classic：经典
- node：node解析策略（唯一的变化，是将js替换成ts）
  - 相对路径**require("./xxx")**
  - 非相对模块**require("xxx")**