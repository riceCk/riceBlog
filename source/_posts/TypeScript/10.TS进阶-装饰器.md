---
title: 10.TS进阶-装饰器
categories: TypeScript
tags: TypeScript
date: 2020-08-03 20:25:00
---

# 装饰器
## 概述
> 面向对象概念（java：注解，C#:特征），decorator
> angular大量使用，react中也会用到
> 目前JS支持装饰器，目前处于征集的第二阶段

## 解决的问题
装饰器，分离关注点
- 关注点的问题：在定义某个东西时，应该最清楚该东西的情况
- 重复代码的问题

上述两个问题产生的根源：某些信息，在定义时能够附加的信息量有限

装饰器的作用：为某些属性、类、参数、方法提供元数据信息（metadata）
元数据：描述数据的数据

### 装饰器的本质
在js中，装饰器是一个函数。（装饰器是要参与运行的）

## 类装饰器
类装饰器的本质是一个函数，该函数接受一个参数，表示类本身（构造函数本身）
使用装饰器`@装饰器名`
在TS中，如何约束一个变量为类
- Function
- `new (参数)=>object`

在TS中要使用装饰器，需要开启`experimentalDecorators:true`

装饰器函数的运行时间：在类定义后之间运行

类装饰器可以具有返回值：
- void：仅允许函数
- 返回一个新的类：会讲新的类替换掉


```bash
# Function 约束
function test (target:  Function ) {}
@test 
class A {}

#new (参数)=>object
function test (target: new (...args: any[]) => object) {
  return class B extends target{}
}
@test 
class A {}

# 调用@test()
function test (str: string) {
  return function (target: new (...args: any[]) => object) {
}

@test("这是一个类")
class A {
  prop1: string
}
```

多装饰器的情况：
- 会按照后加入先调用的顺序进行调用
```bash
type constructor = new (...arg: any[]) => object
function d1(target: constructor) {
  console.log('d1')
}
function d2(target: constructor) {
  console.log('d2')
}
@d1
@d2
class A {}

# d2
# d1
```

## 成员装饰器
- 属性

属性装饰器也是一个函数，该函数需要两个函数：
1.如果是静态属性，则是类本身；如果是实例属性，则为类的原型
2.固定为一个字符串，表示属性名
```bash
function d(target: any, key: string) {
  console.log(target, key)
  # A {} prop1
  # A { _props: [ 'prop1' ] } prop2
  if (!target._props) {
    target._props = []
  }
  target._props.push(key)
}
class A {
  @d
  prop1: string # 实例属性
  @d
  prop2: string # 静态属性
}
console.log((A.prototype as any)._props)
```

- 方法

属性装饰器也是一个函数，该函数需要三个函数：
1.如果是静态属性，则是类本身；如果是实例属性，则为类的原型
2.固定为一个字符串，表示方法名
3.属性描述对象

```bash
function d() {
  return function (target: any, key: string, descriptor: PropertyDescriptor) {
    console.log(target, key, descriptor)
    #A {} 
    # method1
    # {
    #  value: [Function: method1],
    #  writable: true,
    #  enumerable: false,
    #  configurable: true
    # }
}
  }
}
class A {
  @d()
  method1() {}
}
```

## 练习：类和属性的描述装饰器
index.ts
```bash
import {classDescriptor, propDescriptor, printObj} from './Descriptor'

@classDescriptor('用户')
class User {
  @propDescriptor("账号")
  loginId: string
  @propDescriptor("密码")
  loginPwd: string
}
const u = new User();
u.loginId = 'abc'
u.loginPwd = '123'
printObj(u);
```

Descriptor.tx
```bash
export function classDescriptor (description: string) {
  return function (target: Function) {
    // 保存到该类的原型中
    target.prototype.$classDescription = description
  }
}

export function propDescriptor (description: string) {
  return function (target: any, propName: string) {
    // 把所有的属性信息保存到该类的原型中
    if (!target.$propDescriptions) {
      target.$propDescriptions = []
    }
    target.$propDescriptions.push({
      propName,
      description
    })
  }
}

export function printObj(obj: any) {
  if (obj.$classDescription) {
    console.log(obj.$classDescription)
  } else {
    console.log(obj.__propt__.constructor.name)
  }
  if(!obj.$propDescriptions) {
    obj.$propDescriptions = []
  }
  // 输出所有的属性描述和属性值
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const prop = obj.$propDescriptions.find((p: any) => p.propName === key) 
      if (prop) {
        console.log(`\t${prop.description}: ${obj[key]}`)
      } else {
        console.log(`\t${key}: ${obj[key]}`)
      }
    }
  }
}
```
## reflect-metadata库
该库的作用：保存元数据
```bash
import "reflect-metadata"

@Reflect.metadata('a', '一个类')
class A {
  @Reflect.metadata('prop', '一个属性')
  prop1: string
}


const obj = new A()
console.log(Reflect.getMetadata('a', A))
console.log(Reflect.getMetadata('prop', obj, 'prop1'))
```
## class-validator 和 class-transformer库
### class-validator 验证装饰器库
- npm install class-validator --save

```bash
import "reflect-metadata"
import { IsNotEmpty, validate, MinLength, MaxLength, min, Min, Max } from 'class-validator';

class RegUser {
  @IsNotEmpty({message: "账号不可以为空"})
  @MinLength(5, {message: '账号最小有五个字符'})
  @MaxLength(15, {message: '账号最多15个字符'})
  loginId: string
  loginPwd: string
  @Min(0, {message: '年龄最小值为0'})
  @Max(100, {message: '年龄最小值为100'})
  age: number
  gender: '男' | '女'
}

const post = new RegUser()
post.loginId = ''
validate(post).then(errors => {
  console.log(errors)
})
```

## 补充
- 参数装饰器

依赖注入、依赖倒置
要求函数有三个参数：
1.如果方法是静态的，则为类本身；如果方法是实例方法，则为类的原型
2.方法名称
3.在参数列表中的索引

- 关于Ts自动注入的元数据 

如果安装了`reflect-metadata`,并且导入了该库，并且在某个成员上添加了元数据，并且启用了`emitDecoratorMetadata`

则TS在编译结果中，会将约束的类型，作为元数据加入到相应位置

这样一来Ts的类型检查（约束）将有机会在运行时进行

- AOP （aspect oriented programming）

编程方式，属于面向对象开发

将一些在业务中共同出现功能块，横向切分，已达到分离关注点的目的