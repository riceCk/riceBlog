---
title: 6.TS-接口和类型兼容性
categories: TypeScript
tags: TypeScript
date: 2020-05-13 19:36:00
---

# 扩展类型-接口

接口：inteface  

> 扩展类型：类型别名、枚举、接口、类

TypeScript的接口：用于约束、对象、函数的契约（标准）

契约（标准）的形式
- API文档，弱标准
- 代码约束，强标准

## 1.接口约束对象
```bash
interface User {
  name: string,
  age: number
}

let u: User = {
  name: 'sdfa',
  age: 12,
}
```

## 2.接口约束函数
```bash
interface User {
  sayHello: () => void,
  sayHello1(): void
}

let u: User = {
  sayHello () {

  },
  sayHello1 () {
    
  }
}
```
```bash
interface Condition {
  (n:number): boolean
}
function sum(number: number[], callback: Condition) {
  let s = 0;
  number.forEach(n => {
    if (callback(n)) {
      s += n
    }
  })
  return s
}
console.log(sum([3, 4, 5, 6, 11], n => n % 2 !== 0))
```

### 接口可以继承
```bash
interface A {
  T1: string
}

interface B extends A {
  T2: number
}

let u: B = {
  T2: 123,
  T1: '123123'
}

interface C extends A, B {
  T3: boolean
}

let u1: C = {
  T1: '1231',
  T2: 1231,
  T3: false
}
```
可以通过接口之间的继承，实现多种接口的组合

使用类型别名可以实现类似的组合效果，需要通过** & ** ，它叫做交叉类型
```bash
type A = {
  T1: string
}
type B = {
  T2: number
}
type C = {
  T3: boolean
} & A & B
let u1: C = {
  T1: '1231',
  T2: 1231,
  T3: false
}
```

### 他们的区别：
- 子接口不能覆盖父接口的成员

```bash
interface A {
  T1: string
}

interface B extends A {
  T1: number, # 报错
  T2: number
}
```

- 类型别名的交叉类型会把相同成员的类型进行交叉，下面代码**B**中的T1要同时满足**string**以及**number**，所以赋值哪个类型都不正确

```bash
type A = {
  T1: string
}
type B = {
  T1: number, # 不会报错
  T2: number
} & A
```

### readonly 
只读修饰符，修饰的目标是只读，只读修饰符不参与编译，不在编译结果中 
```bash
interface User {
  readonly id: string
  name: string
  age: number
}

let u: User = {
  id: '1231',
  name: 'dfa',
  age: 13
}
u.id = '2321' # 报错

# 并且所以改变数组的方法都失效
let arr: readonly number[] = [2, 3, 5, 6, 6]
arr[0] = 5 # 报错
```

# 类型兼容性
B -> A, 如果能完成赋值，则B和A类型兼容
鸭子辩型法（子结构辩型法）：目标类型需要某一些特征，赋值的类型只要能满足改特征即可

- 基本类型：完全匹配
- 对象类型：鸭子辨型法 

```bash
interface Duck {
  sound: '嘎嘎嘎',
  swin(): void
}

let person = {
  name: '伪装成鸭子的人',
  age: 11,
  sound: '嘎嘎嘎' as '嘎嘎嘎', # 类型断言
  swin () {
    console.log("aaaaa")
  }
}

let duck: Duck = person
```

当直接使用对象字面量赋值的时候，会进行更加严格的判断
```bash
interface Duck {
  sound: '嘎嘎嘎',
  swin(): void
}
let duck: Duck = {
  name: '伪装成鸭子的人', # 报错
  age: 11, # 报错
  sound: '嘎嘎嘎' as '嘎嘎嘎', # 类型断言
  swin () {
    console.log("aaaaa")
  }
}
```

- 函数类型
**参数**：传递给目标函数的参数可以少，但不可以多,下面i可以不传
```bash
interface Condition {
  (n:number, i: number): boolean
}
function sum(number: number[], callback: Condition) {
  let s = 0; 
  number.forEach((n, i) => {
    if (callback(n, i)) {
      s += n
    }
  })
  return s
}
console.log(sum([3, 4, 5, 6, 11], n => n % 2 !== 0))
```

**返回值**：要求返回必须返回；

# 用接口改造程序（扑克牌），加入大小王
```bash
type Deck = Card[]
enum Color {
  heart = "♥",
  spade = "♠",
  club = "♣",
  diamond = "♦"
}

enum Mark {
  A = "A",
  two = '2',
  three = '3',
  four = '4',
  five = '5',
  six = '6',
  seven = '7',
  eight = '8',
  nine = '9',
  ten = '10',
  eleven = 'J',
  twelve = 'Q',
  king = 'k'
}

interface Card {
  getString(): string
}

interface NormalCard extends Card {
  color: Color,
  mark: Mark,
}

interface Joker extends Card {
  type: 'big' | 'small'
}

function createDeck (): Deck {
  const deck: Deck = []
  const maeks = Object.values(Mark);
  const colors = Object.values(Color);
  for (const m of maeks) {
    for (const c of colors) {
      deck.push(<Card>{ // 类型断言，强制定义成功Card类型
        color: c,
        mark: m,
        getString () {
          return this.color + this.mark
        }
      })
    }
  }
  let joker: Joker = {
    type: "small",
    getString () {
      return 'jo'
    }
  }
  deck.push(joker)
  joker = {
    type: 'big',
    getString () {
      return "JO"
    }
  }
  deck.push(joker)
  return deck
}
function printDeck (deck: Deck) {
  deck.forEach(item => {
    console.log(item.getString())
  })
}
printDeck(createDeck())
```