---
title: 前端模块化
categories: 前端模块化Webpack
date: 2020-01-08 16:36:00
---
# 一、模块化的实现
* 函数
* 对象写法-命名空间
* 匿名函数、返回对象
* 依赖传入实参-闭包

## 1、函数
```bash
function add(a,b){
  return a + b;
}
function a (a){
  console.log(a);
}
```
## 2、对象-命名空间
```bash
var ptt = {
  len: 3,
  init: function(){},
  ctrateDom: function(){},
}
```
## 3、匿名函数、返回对象
```bash
#私有化变量
(function(){
  var len = 3;
  function add(a, b){
    return a + b;
  }
  return {
    add: add
  }
})()
```
## 4、依赖-闭包
```bash
(function(a, b){

})(window, function(window){
  window.jQuery = jQuery;
  function jQuery(){}
})
```
# 二、CommonJs规范（node服务器语法）
根CommonJs规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量
## CommonJs思想
CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口

## CommonJs语法
### 暴露接口方式
```bash
module.exports = value
exports.XXX = value
```
### 暴露的模块是什么（exports的本质是什么）？
exports本质是一个空对象
引入模块 require(xxx)

## CommonJs实例
```bash
# index.js
var module = require('module.js');
moudule.add('hell');

#module.js
module.exports = {
  aa:function(str){
    console.log(str)
  }
}
```
## CommonJs缺点
* 浏览器不兼容CommonJs，原因是浏览器缺少module、exports、require、global四个环境变量。如要使用需要工具转换
* CommonJS采用同步加载不同模块文件，适用于服务器端的。因为模块文件都存放在服务器的各个硬盘上，读取加载时间快，适合服务器端，不适应浏览器。

# 三、AMD与CMD（浏览器利用第三方库）
## 下载require.js包
```bash
# main.js中 导入处理
#统一路径 
require.config({  
	baseUrl: './js/tool',
	paths: {
		'jquery': 'jquery',
		'math': 'math'
	}
})

require(['jquery', 'math'], function($, math){
	#模块导入
	console.log($());  #继续实现功能
	console.log(math.add(1, 2));
})

# math.js 子方法
define(['myLib'], function(myLib){  
 #模块定义 + 模块导入
    console.log(myLib.a);   #获取模块myLib值
    function add(a, b){
        return a + b;
    }
    return {
        add : add
    }
})

# myLib.js 子方法
define(function(){  //定义模块
    return {
        a: 123
    }
})

```
# 四、ES6模块化
## 1.基本的导入导出 
### 1.1.基本的导出方式 
基本的导出方式分为两种
```bash
export 声明表达式
```
或者
```bash
export {具名表达式}
```
由于基本导出必须具有名称，所以吧要求导出内容必须更上**声明表达式**或**具名符号**
```bash
# 1
export var a = 1;
export function test () {

}

# 2
var age = 18;
var sex = 1
export {
    age,
    sex
}

```

### 1.2 基本导入 
由于使用的是**依赖预加载**，因此，导入任何其他模块，导入代码必须放置到所有代码之前
对于基本导出，如果进行导入，使用下面的代码
```bash
import {导入的符号列表} from '模块路径'
import {b as b2} from '模块路径'
import * as from '模块路径'
```
注意以下细节：
* 导入时，可以通过关键字as对导入的符号进行重命名
* 导入时使用的符号是常量，不可修改
* 可以使用*号导入所有的基本导出，形成一个对象


## 2.默认的导入导出
### 2.1 默认导出
每个模块，除了允许有多个基本导出之外，还允许有一个默认导出
默认导出类似于CommonJS中的module.exports,由于只有一个，因此无需具有
具体的语法是：
```bash
export default 默认导出的数据
```
或
```bash
export {默认导出的数据 as default}
```
由于每个模块仅允许有一个默认导出，因此，每个模块不能出现多个默认导出语句

### 2.2 默认导入
需要想要导入一个模块的默认导出，需要使用下面的语法
```bash
import 接受变量 from '模块路径'
```
类似于CommonJS中的
```bash
var 接受变量名 = require('模块路径')
```
由于默认导出时变量名是自行定义的，因此没有别名一说
如果需要同时导入某个模块的默认导出和基本导出，可以使用下面的语法
```bash
import 接受默认导出的变量, {接受基本导出的变量} from '模块路径'
```
注：如果使用*号，会将所有基本导出和默认导出聚合到一个对象中，默认导出会作为属性default存在

## 3.ES6模块化的其他细节
### 3.1尽量导出不可变值
当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）
因为，虽然导入后，无法改变导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生
### 3.2可以使用无绑定的导入用于执行一些初始代码
如果我们只是想执行模块中的一些代码，而不需要导入他们的任何内容，可以使用无绑定的导入
```bash
# 相当于模块中js立即执行
import '模块路径'
```
### 3.3可以使用绑定在导出，来重新导出自另一个模块的内容
有时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成
```bash
export {绑定的标识符} from '模块路径'
export const r = 'm-r';

export {a, b} from './m1.js'
export {k, default as m2} from './m2.js'
```

# 五、webpack自动化打包工具的配置
## webpack 命令行配置
```bash
#初始化
npm init
# 在本地文件下载webpack定义开发环境
npm install webpack --save-dev
# 下载webpack支架，webpack4之后需要单独下载
cnpm install webpack-cli -g
# 自定义打包
webpack demo.js -o bundle.js
```
## 创建入口文件
webpack4之后到这边必须创建一个src文件下index.js入口文件，webpack3之前没问题，基于4之后就必须创建否则报错，之后运行webpack命令会自动创建一个dist出口文件

## 四个核心模块及概念
* 入口 entry
入口起点指 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的

* 输出 output
告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。

* 依赖 loader
loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。

* 插件 plugins
插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

## 模块化
```bash
# 主入口文件中
var demo = require('./demo.js');
demo.add(22, 33);

#模块化子组件
module.exports = {
  add: function(a, b){
    console.log(a + b);
  }
}
```
## 图片的打包
### webpack.config.js的配置
```bash
module.exports = {
  #入口配置
  entry:{
    demo: './src/demo.js',
    index: './src/index.js'
  },
  #输出配置
  output: {
    path: __dirname + '/out',
    filename: '[name].bundle.js',
    publicPath: './out'
  },
  module: {
    rules: [
      {test:/.jpg$/,use:['url-loader?limit=10?&name=/[name].[ext]']}
    ]
  },
  #开发环境
  mode: 'development'
}
```
### 下载的依赖
```bash
npm install url-loader --save-dev
npm install file-loader --save-dev
```
### 入口文件的配置
```bash
# 入口文件 index.js
var img = new Image();
img.src = require('./img/7.jpg');
document.body.appendChild(img);
```
# 六、浅谈MVC、MVP及MVVM
## MVC
![MVP](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/MVC.jpg)
* 控制器负责管理视图和模型；
* 视图负责展示模型中的内容；

## MVP
MVP框架模型是MVC的一种变种，很多框架都自称遵循MVC框架模式，但是他们实际上却实现了MVP模式，`M`则是**model**模型，`M`则是**View**视图，`p`则是**Presenter**，模型和视图彼此一无所知，通过Presenter进行沟通。
![MVP](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/MVP.jpg)
* 当视图接收到来自用户事件时，会将事件转交给Presenter进行处理；
* 被动的视图向外界暴露接口，当需要更新视图时Presenter通过视图暴露的接口更新视图的内容
* Presenter负责对模型进行操作和更新，在需要时取出其中存储的信息；
* 当模型改变时，可以将改变的信息发送给观察者Presenter；

## MVVM:视图模式 
Model-View-ViewModel，他由三个部分组成Model、View和ViewModel；其中视图模型（ViewModel）其实就是PM模式中的展示模型，在MVVM中叫做视图模型，除了我们非常属性的Model、View和ViewModel这三个部分，在MVVM的实现中，还引入了**隐私**一个Binder层，而声明式的数据和命令的绑定在MVVM模式中就通过它完成。

