---
title: 二维数据结构（二叉树）
categories: 前端算法
date: 2020-04-23 16:36:00
---

# 栈和队列
栈：先进后出，类比成一个箱子，先放进去的，被压在下面
队列：先入先出，类比出一个管道

# 二维数据结构，拓扑结构
![拓扑结构](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/topology.jpg)
```bash
## 二维数组
let arr = new Array(4);
for (let i = 0; i < arr.length; i++) {
  arr[i] = new Array(8)
}

## 拓扑结构
function Node (value) {
  this.value = value;
  this.neighbor = []
}

let a = new Node('a');
let b = new Node('b');
let c = new Node('c');
let d = new Node('d');
let e = new Node('c');
let f = new Node('f');
a.nextSibling.push(b);
a.nextSibling.push(c)
a.nextSibling.push(f);

b.nextSibling.push(a);
b.nextSibling.push(d);
b.nextSibling.push(e)

c.nextSibling.push(a);

d.nextSibling.push(b);

e.nextSibling.push(b);
```



# 树形结构--有向无环图 
![树形结构](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/treeShape.png)
树形结构有一个根节点，树形结构没有回路
根节点：A
**叶子节点：**下边没有其他节点啦，C、F、D、E
**节点：**既不是根节点，又不是叶子节点普通节点，B
**树的度：**这棵最多有叉的节点有多少个叉，这棵树的度就位多少
**树的深度：**树最深有几层，树的深度就位几，3层

## 二叉树之满二叉树
![二叉树之满二叉树](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/fullTree.png)
树的度最多为2个树形结构，
* 所有的叶子节点都在最底层
* 每个非叶子节点都有两个子节点

**二叉树根节点：**A
**子节点：**某个节点下面的节点
**父节点：**上级节点
**叶子节点：**FGDE
**节点：**CB


## 完全二叉树
**国内定义**
*（1）叶子节点都在最后一层或者倒数第二层
*（2）叶子节点都向左聚拢

![国内定义](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/domestic.png)

**国际定义**
*（1）叶子节点都在最后一层或者倒数第二层
*（2）如果有叶子节点，就必然有两个叶子节点

![国际定义](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/international.png)

## 二叉树中子树的概念
在二叉树中，每个节点都认为自己是根节点
**子树：**二叉树中，每一个节点或者叶子节点，都是一颗子树的根节点
**左子树、右子树：**

## 二叉树的遍历
先搞个二叉树数据
![二叉树之满二叉树](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/fullTree.png)
```bash
function Node (value) {
  this.value = value
  this.left = null;
  this.right = null;
}
var a = new Node('a');
var b = new Node('b');
var c = new Node('c');
var d = new Node('d');
var e = new Node('e');
var f = new Node('f');
var g = new Node('g');
  
a.left = c;
a.right = b;
c.left = f;
c.right = g;
b.left = d;
b.right = e;
```
### 前序遍历：（先根次序遍历）
先打印当前的，在打印左边的，在打印右边的（ACFGBDE）
```bash
function f1 (root) {
  if (root == null) return;
  console.log(root.value);
  f1(root.left);
  f1(root.right);
}
f1(a)
```

### 中序遍历：（中根次序遍历）
先打印左边的，在打印当前的，在打印右边的（FCGADBE）
```bash
function f1 (root) {
  if (root === null) return;
  f1(root.left);
  console.log(root.value)
  f1(root.right)
}
f1(a)
```
### 后序遍历：（后根次序遍历）
先打印左边的，在打印右边的，在打印当前的（FGCDEBA） 
```bash
function f1 (root) {
  if (root === null) return;
  f1(root.left);
  f1(root.right)
  console.log(root.value)
}
f1(a)
```

## 代码实现前序中序还原二叉树
```bash
let qian = ['a', 'c', 'f', 'g', 'b', 'd', 'e'];
let zhong = ['f', 'c', 'g', 'a', 'd', 'b', 'e'];

function Node (value) {
  this.value = value;
  this.left = null
  this.right = null
}

function f1 (qian, zhong) {
  if (qian == null || zhong  === null || qian.length === 0 || zhong.length === 0 || qian.length !== zhong.length) return null
  let root = new Node(qian[0]);
  # 找到跟节点在中序遍历中的位置
  let index = zhong.indexOf(root.value);
  let leftqian = qian.slice(1, index + 1)
  let rightqian = qian.slice(index + 1)
  let leftzhong = zhong.slice(0, index);
  let rightzhong = zhong.slice(index + 1)
  root.left = f1(leftqian, leftzhong);
  root.right = f1(rightqian, rightqian)
  return root
}
```

## 代码实现中序后序还原二叉树
```bash
let zhong = ['f', 'c', 'g', 'a', 'd', 'b', 'e'];
let hou = ['f', 'g', 'c', 'd', 'e', 'b', 'a'];

function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

function f1 (zhong, hou) {
  if (zhong === null || hou === null || zhong.length === 0 || hou.length === 0 || zhong.length !== hou.length ===0) return null;
  let root = new Node(hou[hou.length - 1]);
  let index = zhong.indexOf(root.value);
  let zhongLeft = zhong.slice(0, index);
  let zhongRight = zhong.slice(index + 1);
  let houLeft = hou.slice(0, index);
  let houRight = hou.slice(index, hou.length - 1)
  root.left = f1(zhongLeft, houLeft);
  root.right = f1(zhongRight, houRight)
  return root
}
console.log(f1(zhong, hou))
```
 
## 二叉树的搜索
### 深度优先搜索
更适合单说未知，优先往深度搜索
**代码实现**
```bash
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

let a = new Node('a');
let b = new Node('b');
let c = new Node('c');
let d = new Node('d');
let e = new Node('e');
let f = new Node('f');
let g = new Node('g');

a.left = c;
a.right = b;
c.left = f;
c.right = g;
b.left = d;
b.right = e;

function deepSearch(root, target) {
  if (root === null) return false;
  if (root.value === target) return true;
  let left = deepSearch(root.left, target);
  let right = deepSearch(root.right, target);
  return left || right
}
```
### 广度优先搜索
更适合探索局域，优先一层一层搜索
```bash
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

let a = new Node('a');
let b = new Node('b');
let c = new Node('c');
let d = new Node('d');
let e = new Node('e');
let f = new Node('f');
let g = new Node('g');

a.left = c;
a.right = b;
c.left = f;
c.right = g;
b.left = d;
b.right = e;

function deepSearch(rootList, target) { 
  if (rootList == null || rootList.length == 0) return false;
  let childList = []
  for (let i = 0; i < rootList.length; i++) {
    if (rootList[i] !== null && rootList[i].value === target) {
      return true
    } else {
      childList.push(rootList[i].left)
      childList.push(rootList[i].right)
    }
  }
  return deepSearch(childList, target)
}
```

## 二叉树的比较
### 左右互换不是同一个棵树做判断
```bash
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

let a1 = new Node('a');
let b1 = new Node('b');
let c1 = new Node('c');
let d1 = new Node('d');
let e1 = new Node('e');
let f1 = new Node('f');
let g1 = new Node('g');

a1.left = c1;
a1.right = b1;
c1.left = f1;
c1.right = g1;
b1.left = d1;
b1.right = e1;

let a2 = new Node('a');
let b2 = new Node('b');
let c2 = new Node('c');
let d2 = new Node('d');
let e2 = new Node('e');
let f2 = new Node('f');
let g2 = new Node('g');

a2.left = c2;
a2.right = b2;
c2.left = f2;
c2.right = g2;
# b2.left = d2;
b2.right = e2;

function compareTree(root1, root2) {
  # 两颗是同一颗树
  if (root1 === root2) return true;
  # 两棵其中有一个是null
  if (root1 == null && root2 != null || root2 == null && root1 != null) return false;
  # 两个树相同位置值不相等
  if (root1.value != root2.value) return false
  let leftBool = compareTree(root1.left, root2.left);
  let rightBool = compareTree(root1.right, root2.right);
  return leftBool && rightBool
}
console.log(compareTree(a1, a2));
```

### 左右互换是同一个树做判断
```bash
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

let a1 = new Node('a');
let b1 = new Node('b');
let c1 = new Node('c');
let d1 = new Node('d');
let e1 = new Node('e');
let f1 = new Node('f');
let g1 = new Node('g');

a1.left = c1;
a1.right = b1;
c1.left = f1;
c1.right = g1;
b1.left = d1;
b1.right = e1;

let a2 = new Node('a');
let b2 = new Node('b');
let c2 = new Node('c');
let d2 = new Node('d');
let e2 = new Node('e');
let f2 = new Node('f');
let g2 = new Node('g');

a2.left = c2;
a2.right = b2;
c2.left = f2;
c2.right = g2;
b2.left = d2;
b2.right = e2;

function compareTree(root1, root2) {
  # 两颗是同一颗树
  if (root1 === root2) return true;
  # 两棵其中有一个是null
  if (root1 == null && root2 != null || root2 == null && root1 != null) return false;
  # 两个树相同位置值不相等
  if (root1.value != root2.value) return false
  let leftBool = compareTree(root1.left, root2.left) && compareTree(root1.right, root2.right);
  let rightBool = compareTree(root1.left, root2.right) && compareTree(root1.right, root2.left);
  return leftBool ||  rightBool
}
console.log(compareTree(a1, a2));
```

### 二叉树的diff算法
```bash
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
let a1 = new Node('a');
let b1 = new Node('b');
let c1 = new Node('c');
let d1 = new Node('d');
let e1 = new Node('e');
let f1 = new Node('f');
let g1 = new Node('g');

let a2 = new Node('a');
let b2 = new Node('b');
let c2 = new Node('c');
let d2 = new Node('d');
let e2 = new Node('e');
let f2 = new Node('f');
let g2 = new Node('g');
let j2 = new Node('j');

a1.left = c1;
a1.right = b1;
c1.left = f1;
c1.right = g1;
b1.left = d1;
b1.right = e1;

a2.left = c2;
a2.right = b2;
c2.left = f2;
# c2.right = g2;
b2.left = j2;
b2.right = e2;
e2.left = d1

function diffTree(root1, root2, diffList) {
  if (root1 == root2) return diffList;
  if (root1 == null && root2 != null) {
    #  新增节点
    diffList.push({type: '新增', origin: null, now: root2});
  } else if (root1 != null && root2 == null) {
    # 删除节点
    diffList.push({type: '删除', origin: root1, now: null})
  } else if (root1.value != root2.value) {
    # 相同配置的节点值不同，修改了节点
    diffList.push({type: "修改", origin: root1, now: root2})
  } else {
    diffTree(root1.left, root2.left, diffList)
    diffTree(root1.right, root2.right, diffList)
  }
}
let diffList = [];
diffTree(a1, a2, diffList);
console.log(diffList)
```

# 图的最小生成树问题
## 普利算法（加点法）
* 1.任意一个点为起点
* 2.找到以当前选中点为起点路径最短的边
* 3.如果这边的另一端没有被联通进行，那边就连接
* 4.如果这个边的另一端也早就被连进来，则看倒数第二短的边
* 5.重复2-4直到将所有点都连通为止

## 克鲁斯卡尔算法（加边法）
* 1.选择最短的边进行连接
* 2.要保证边连接的两端至少有一个点是新的点
* 3.或者这边是将两个部落进行连接的
* 4.重复1-3直到将所有点都连接到一起 