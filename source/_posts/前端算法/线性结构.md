---
title: 线性结构
categories: 前端算法
date: 2020-04-12 16:36:00
---

# 线性结构之链表
```bash
function Node(value) {
  this.value = value;
  this.next = null;
}

let a = new Node(1);
let b = new Node(2);
let c = new Node(3);
let d = new Node(4);

a.next = b;
b.next = c; 
c.next = d;
d.next = null

console.log(a.value)
console.log(a.next.value)
console.log(a.next.next.value)
```
## 链表的特点：
1.空间上不是连续的
2.每存放一个值，都要多开销一个应用空 间

### 优点：
1.只要内存足够大，就能存的下，不用担心空间碎片
2.链表的添加和删除非常的容易

### 缺点：
1.查询速度慢，（指的查询某个位置）
2.链表每一个节点都需要创建一个指向next的引用，浪费一些空间。
当节点内数据越多的时候，这部分多开销的内存影响越小

## 链表的循环遍历
```bash
function Node(value) {
  this.value = value;
  this.next = null;
}

let node1 = new Node(1);
let node2 = new Node(2);
let node3 = new Node(3);
let node4 = new Node(4);

node1.next = node2;
node2.next = node3; 
node3.next = node4;
node4.next = null

function bianLink (root) {
  let temp = root;
  while (true) {
    if (temp != null){
      console.log(temp.value , temp);
    } else { 
      break
    }
    temp = temp.next;
  }
}

bianLink(node1);
```

## 链表的递归遍历
```bash
function Node(value) {
  this.value = value;
  this.next = null;
}

let node1 = new Node(1);
let node2 = new Node(2);
let node3 = new Node(3);
let node4 = new Node(4);

node1.next = node2;
node2.next = node3; 
node3.next = node4;
node4.next = null

function binLink (root) {
  if (root == null) return
  console.log(root.value);
  binLink(root.next);
}
bianLink(node1);
``` 

## 链表的逆置
```bash
function Node(value) {
  this.value = value;
  this.next = null;
}

let node1 = new Node(1);
let node2 = new Node(2);
let node3 = new Node(3);
let node4 = new Node(4);

node1.next = node2;
node2.next = node3; 
node3.next = node4;
node4.next = null

function nizhi(root) {
  if (root.next.next == null) {
    root.next.next = root
    return
  } else {
    nizhi(root.next)
    root.next.next= root
    root.next = null
  }
}
```
## 双向链表
```bash
function Node (value) {
  this.value = value;
  this.next = null;
  this.pre = null
}
let node1 = new Node(1)
let node2 = new Node(2)
let node3 = new Node(3)
let node4 = new Node(4)
let node5 = new Node(5)

node1.next = node2;
node2.pre = node1;
node2.next = node3; 
node3.pre = node2;
node3.next = node4;  
node4.pre = node3;
node4.next = node5;
node5.pre = node4
```


