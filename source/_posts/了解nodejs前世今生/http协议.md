---
title: httt协议
categories: 了解nodejs前世今生
tags: 面试题
date: 2018-07-23 09:47:00
---
# 五层⽹络协议
| TCP/IP层     | 网络设备    |   
| :------:   | :-----:   | 
|应用层       |           |
|传输层      | 四层交换机，也有工作在四层的路由器         |
|网络层       |   路由器、三层交换机        |
|数据链路层       | 网桥（很少使用）、以太网交换机（二层交换机）、网卡（一半工作在物理层、一半工作在数据链路层）          |
|物理层   | 中继器、集线器、还有我们通常说的双绞线也工作在物理层          |
## 应⽤层
与其它计算机进⾏通讯的⼀个应⽤，它是对应应⽤程序的通信服务的。例如，⼀个没有通信功能的字处理程序就不能执⾏通信的代码，从事字处理⼯作的程序员也不关⼼OSI的第7层。但是，如果添加了⼀个传输⽂件的选项，那么字处理器的程序员就需要实现OSI的第7层。示例：TELNET，HTTP,FTP,NFS,SMTP等。
## 传输层
这层的功能包括是否选择差错恢复协议还是⽆差错恢复协议，及在同⼀主机上对不同应⽤的数据流的输⼊进⾏复⽤，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。
## ⽹络层
这层对端到端的包传输进⾏定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的⽅式和学习的⽅式。为了适应最⼤传输单元⻓度⼩于包⻓度的传输介质，⽹络层还定义了如何将⼀个包分解成更⼩的包的分段⽅法。示例：IP,IPX等。
## 数据链路层
它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。
## 物理层
OSI的物理层规范是有关传输介质的特性标准，这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使⽤、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常⽤多个规范完成对所有细节的定义。示例：Rj45，802.3等。
## 以邓哥送信为例
* 应用层： 浏览器（HTTP）（HTTP协议（邓哥暗号）：天王盖地虎）、DNS协议（协议解析），FTP协议（文件传输），SMTP协议（邮箱传输），Telnet
* 传输层： TCP/UDP(TCP：会保证数据的正确性的，也会保证数据的顺序性；UPD: 尽最大的努力保证数据送到，但这种情况下会有丢包的情况)
200: 收到信了，服务器也回信了
401：服务器http协议格式问题，无法访问
403：服务器拒绝请求
404：没找到这个人
301：人搬家了，搬到XXX地方，送信的人再去这个地方过程叫做永久移动
302：人去闺蜜家，这种过程叫做临时重定向
303：送信的人到了闺蜜家，但是送信的人是post请求，闺蜜家开门需要get请求
304： 当第二次传输时，接收方让发送方还看第一次传输的信息，不会二次回信，使用上一次的信
500：浏览器（邓哥的信）已经被送到服务器手，httl协议也符合，但是拿到信的服务器读信（解析）过程中发生错误，报的500。
502：服务器错误，地方找到了，人也在，就是不开门
503：请求服务器的时候，服务器正在繁忙

资料参考[《邓哥奇遇记2》——HTTP协议状态码](https://mp.weixin.qq.com/s?__biz=MzI2NTQ5NTE4OA==&mid=2247486690&idx=1&sn=1489f7722666c02f8f3b4920b503d0a9&chksm=ea9d3b19ddeab20f38d92cc9c7ac312c8032409e0298b21b072d57fe09e3aa16f9244c5a5fc0&mpshare=1&scene=1&srcid=0717KJwoo6Fq1dFGUpHKT73r#rd)

* 网络层： IP（送信的地址）、ICMP、RIP、BGP
* 数据链路层： 分为两个子层-逻辑链路控制子层/媒体访问控制子层（MAC地址），如何传输（搭乘什么样的交通工具过去）
* 物理层： ISO2110的物理层规范（搭乘工具的时候是什么速度，需要使用公交卡、扫码等）

# 七层协议
* 应用层
* 表示层： 加密、格式转换（莫斯电码）
* 会话层： 解除或者建立和其他节点的联系
* 传输层
* 网络层
* 数据链路层
* 物理层

```bash
# linux中获取百度内容代码
curl www.baidu.com
# 获取百度返回头的信息
cur -i www.baidu.com
```
# HTTP协议
超文本传输协议（HyperText Transfer Protocol）
![响应头](https://raw.githubusercontent.com/riceCk/riceBlog/master/images/22.png)
## Accept
作⽤： 浏览器端可以接受的媒体类型,
例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为text/html 也就是我们常说的html⽂档,如果服务器⽆法返回text/html类型的数据,服务器应该返回⼀个406错误(non acceptable)通配符 * 代表任意类型例如 Accept: */* 代表浏览器可以处理所有类型,(⼀般浏览器发给服务器都是发这个)
## Accept-Encoding：
作⽤： 浏览器申明⾃⼰接收的编码⽅法，通常指定压缩⽅法，是否⽀持压缩，⽀持什么压缩⽅法（gzip，deflate），（注意：这不是只字符编码）;
例如： Accept-Encoding: zh-CN,zh;q=0.8
## Accept-Language
作⽤： 浏览器申明⾃⼰接收的语⾔。语⾔跟字符集的区别：中⽂是语⾔，中⽂有多种字符集，⽐如big5，gb2312，gbk等等；
例如： Accept-Language: en-us

## Cache-Control
告诉所有的缓存机制是否可以缓存及哪种类型
**属性**
### public：
表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。
### private 
内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓 存)
### no-cache
强制所有缓存了该响应的缓存⽤户，在使⽤已存储的缓存数据前，发送带验证器的请求到原始服务器，必须先与服务器确认返回的响应是否被更改，然后才能使用该响应 来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌  (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源 未被更改，可以避免下载。
### no-store 所有内容都不会被缓存到缓存或 Internet 临时文件中 
### must-revalidation/proxyrevalidation 
如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 
**到期缓存**
### max-age=xxx (xxx is numeric 到期缓存)
设置缓存存储的最⼤周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间，缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如 果和Last-Modified一起使用时, 优先级较高
### only-if-cached
表明如果缓存存在，只使⽤缓存，⽆论原始服务器数据是否有更新。
### s-maxage=<seconds>
覆盖max-age 或者 Expires 头，但是仅适⽤于共享缓存(⽐如各个代理)，并且私有缓存中它被忽略。
### max-stale[=<seconds>]
表明客户端愿意接收⼀个已经过期的资源。 可选的设置⼀个时间(单位秒)，表示响应不能超过的过时时间。
### min-fresh=<seconds>
表示客户端希望在指定的时间内获取最新的响应
**重新验证和重新加载：**
### must-revalidate
缓存必须在使⽤之前验证旧资源的状态，并且不可使⽤过期资源。
### proxy-revalidate
与must-revalidate作⽤相同，但它仅适⽤于共享缓存（例如代理），并被私有缓存忽略。
### immutable
表示响应正⽂不会随时间⽽改变。资源（如果未过期）在服务器上不发⽣改变，因此客户端不应发送重新验证请求头（例如If-None-Match或IfModified-Since）来检查更新，即使⽤户显式地刷新⻚⾯。在Firefox中，immutable只能被⽤在 https:// transactions.
**其他**
### no-store
缓存不应存储有关客户端请求或服务器响应的任何内容。
### no-transform
不得对资源进⾏转换或转变。Content-Encoding, Content-Range, ContentType等HTTP头不能由代理修改。例如，⾮透明代理可以对图像格式进⾏转
换，以便节省缓存空间或者减少缓慢链路上的流量。 no-transform指令不允
许这样做。

## Age              
从原始服务器到代理缓存形成的估算时间（以秒计，非负）  
Age: 12
## Allow            
对某网络资源的有效的请求行为，不允许则返回405        
Allow: GET, HEAD

## Connection
例如：　Connection: keep-alive 当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的⽹⻚，会继续使⽤这⼀条已经建⽴的连接
例如： Connection: close 代表⼀个Request完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建⽴TCP连接。Host（发送请求时，该报头域是必需的）作⽤: 请求报头域主要⽤于指定被请求资源的Internet主机和端⼝号，它通常从HTTP URL中提取出来的
例如: 我们在浏览器中输⼊：http://www.hzau.edu.cn浏览器发送的请求消息中，就会包含Host请求报头域，如下：
Host：www.hzau.edu.cn此处使⽤缺省端⼝号80，若指定了端⼝号，则变成：Host：指定端⼝号

## Referer
当浏览器向web服务器发送请求的时候，⼀般会带上Referer，告诉服务器我是从哪个⻚⾯链接过来的，服务器籍此可以获得⼀些信息⽤于处理。⽐如从我主⻚上链接到⼀个朋友那⾥，他的服务器就能够从HTTP Referer中统计出每天有多少⽤户点击我主⻚上的链接访问他的⽹站。

## User-Agent
作⽤：告诉HTTP服务器， 客户端使⽤的操作系统和浏览器的名称和版本.我们上⽹登陆论坛的时候，往往会看到⼀些欢迎信息，其中列出了你的操作系统的名称和版本，你所使⽤的浏览器的名称和版本，这往往让很多⼈感到很神奇，实际上，服务器应⽤程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。
例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; WindowsNT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2;.NET4.0E)


[一篇文章带你详解 HTTP 协议](https://www.jianshu.com/p/6e9e4156ece3?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)

# TCP的三次握手四次挥手
## TCP的三次握手
三次握手主要的目的是为了确认两台主机都具备收和发的能力
**以邓哥和绿茶妹为例**
### 第一次握手让B主机知道A可以发出消息
A发出的信息,seq本机准备发送的序号
* SYN(请求建立连接) = 1
* seq(发) = 249

第一张纸条：表示三次握手的第一次握手，主要传递两个信息，一是请求建立连接，二是发出一个序列号。在实际连接中，请求建立连接用SYN=1表示，序列号用seq=n表示，其中n为一个数。在邓哥传条的过程中，邓哥说这条纸条的序号是249，“我们开始传条聊天呀？”就相当于是请求建立连接
### 第二次握手让A知道了B能接收到，也能发出
B发出的信息，ack表示本机收到的序号，seq本机准备发送的序号
* ack(收) = 249 + 1 = 250
* seq(发) = 99

第二次握手~注意邓哥发的序号是249，绿茶回复的是收到250。在实际情况中，这次回复一共有三条信息，一是同意建立连接邓哥（SYN = 1），二是确认收到了刚才的信息（ack = 刚才的seq + 1），三是发出自己的序列号（seq = x，其中x为一个数）。绿茶回复“收到250”这句话表示收到了刚才的信息，对刚才的序号做加一处理，所以收到的是249，回复的是250。“这张纸条的序号是99”这句话是绿茶发出的序号。在第一次传条中`B知道了A可以发`，第二张纸条发出，A接到之后，`A知道了B可以接收也能发出`。那么这个时候，还有一个没有证明，那就是`B还不知道A能不能接收到自己的纸条`。所以B要生成一个数，让A回复这个数加一才能确认A也能接收到消息。这就是绿茶要发出序号的原因
### 第三次握手让B知道了A能接收到
A发出的信息
* ack(收) = 100
* seq(发) = 250

第三次握手，三条信息，一是表示现在开始发送（SYN = 0），二是成功收到了绿茶的信息（ack=刚才的seq + 1），三是这张纸条的序号（seq=最开始发出的序号 + 1）

## TCP四次挥手  已邓哥为邓嫂喂饭为例
### 这就是第一次挥手：A告诉B数据发送完了
这时候相当于A向B传输数据，数据传递完了，但是数据传递完了之后，不能直接断开，因为B并不知道数据传递完了，所以A（邓哥）告诉B（邓嫂）数据传递完了
### 这就是第二次挥手：B知道A发完了
因为B（邓嫂）还没有接受完数据（没有咽下），所以虽然知道A（邓哥）把数据传完了（喂完了），所以只能先回复A（邓哥）知道你传完了（喂完了）
### 这就是第三次挥手：B告诉A接收完了
虽然A（邓哥）已经发送完了数据，但是还不确定B（邓嫂）接收完数据，所以A还要等着，因为一旦B没有接收成功，A还要继续发送。所以A要等着B反馈已经接收完了，才能真正断开连接。所以这时候当B接收完数据的时候，B要告诉A接收完了。
### 这就是第四次挥手：A知道B接收完了
这时A（邓哥）知道了B（邓嫂）接收完数据了，就可以放心的断开连接了