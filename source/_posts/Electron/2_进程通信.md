---
title: 2_进程通信
categories: Electron
tags: Electron
date: 2024-01-11 09:47:00
---

# 通信

## 1.主进程和渲染进程通信
- 主进程和渲染进程之间的通信
- 渲染进程彼此之间的通信

在 Electron 中，已经对应的模块 ipcMain 和 ipcRenderer 来实现这两类进程之间的通信。

### ipcMain模块

**ipcMain.on(channel, listener)**

- 这个很明显是一个监听事件，on 方法监听 channel 频道所触发的事件
- listener 是一个回调函数，当监听的频道有新消息抵达时，会执行该回调函数
  - listener(event, args...)
    - event 是一个事件对象，event.reply => 回复渲染进程
    - args 是一个参数列表

**ipcMain.once(channel, listener)：**和上面 on 的区别在于 once 只会监听一次
**ipcMain.removeListener(channel, listener)：**移除 on 方法所绑定的事件监听。

具体可以参阅：https://www.electronjs.org/docs/latest/api/ipc-main

### ipcRenderer模块

基本上和上面的主进程非常的相似。
**ipcRenderer.on(channel, listener)**
  - 和上面主进程的 on 方法用法一样

**ipcRenderer.send(channel, ...args)**
  - 此方法用于向主进程对应的 channel 频道发送消息。
  - 注意 send 方法传递的内容是被序列化了的，所以并非所有数据类型都支持

这两个模块实际上是基于 Node.js 里面 EventEmitter 模块实现的。例如：

```js
// index.js
const event = require('./event');
// 触发事件
event.emit("some_event");
```

```js
event.js
const EventEmitter = require("events").EventEmitter;
const event = new EventEmitter();

// 监听自定义事件
event.on("some_event", () => {
  console.log("事件已触发");
});

module.exports = event;
```

### 代码栗子

**渲染进程 window.js**
```bash
## 获取button的DOM节点
const btn = document.getElementById('btn');
btn.addEventListener('click', () => {
    # 创建一个http请求
    const req = http.request(options, (res) => {
        res.setEncoding('utf-8')
        res.on('data', (data) => {
            # 拿到的数据之后，发送给主进程
            ipcRenderer.send('test', data)
        })
    })
    # 发送http请求
    req.write('')
    # 请求结束
    req.end();
})
## 监听主线程回复的信息
ipcRenderer.on('data-res', (event, data) => {
    console.log('主进程回复的消息为：', data)
})
```

**主进程 index.js**
```bash
const { ipcMain } = require('electron');
# 创建一个监听频道
ipcMain.on('test', (event, data) => {
    # 主进程拿到之后，和渲染进程回复
    try {
        console.log(data, '主进程')
        # 回复渲染进程
        event.reply('data-res', '主进程已经收到消息了')
    } catch(err){}
})
```
