---
title: 2.进程通信
categories: Electron
tags: Electron
date: 2024-01-11 09:47:00
---

## 1.主进程和渲染进程通信
- 主进程和渲染进程之间的通信
- 渲染进程彼此之间的通信

在 Electron 中，已经对应的模块 ipcMain 和 ipcRenderer 来实现这两类进程之间的通信。

### ipcMain模块

**ipcMain.on(channel, listener)**

- 这个很明显是一个监听事件，on 方法监听 channel 频道所触发的事件
- listener 是一个回调函数，当监听的频道有新消息抵达时，会执行该回调函数
  - listener(event, args...)
    - event 是一个事件对象，event.reply => 回复渲染进程
    - args 是一个参数列表

**ipcMain.once(channel, listener)：**和上面 on 的区别在于 once 只会监听一次
**ipcMain.removeListener(channel, listener)：**移除 on 方法所绑定的事件监听。

具体可以参阅：https://www.electronjs.org/zh/docs/latest/api/ipc-main

### ipcRenderer模块

基本上和上面的主进程非常的相似。
**ipcRenderer.on(channel, listener)**
  - 和上面主进程的 on 方法用法一样

**ipcRenderer.send(channel, ...args)**
  - 此方法用于向主进程对应的 channel 频道发送消息。
  - 注意 send 方法传递的内容是被序列化了的，所以并非所有数据类型都支持

这两个模块实际上是基于 Node.js 里面 EventEmitter 模块实现的。例如：

```js
// index.js
const event = require('./event');
// 触发事件
event.emit("some_event");
```

```js
event.js
const EventEmitter = require("events").EventEmitter;
const event = new EventEmitter();

// 监听自定义事件
event.on("some_event", () => {
  console.log("事件已触发");
});

module.exports = event;
```

**ipcRenderer.postMessage(channel, message, [transfer])**
  - 发送消息到主进程，同时可以选择性发送零到多个 MessagePort 对象
```bash
// 渲染进程
const { port1, port2 } = new MessageChannel()
ipcRenderer.postMessage('port', { message: 'hello' }, [port1])

// 主进程
ipcMain.on('port', (e, msg) => {
  const [port] = e.ports
  // ...
})
```

### 代码栗子

**渲染进程 window.js**
```bash
## 获取button的DOM节点
const btn = document.getElementById('btn');
btn.addEventListener('click', () => {
    # 创建一个http请求
    const req = http.request(options, (res) => {
        res.setEncoding('utf-8')
        res.on('data', (data) => {
            # 拿到的数据之后，发送给主进程
            ipcRenderer.send('test', data)
        })
    })
    # 发送http请求
    req.write('')
    # 请求结束
    req.end();
})
## 监听主线程回复的信息
ipcRenderer.on('data-res', (event, data) => {
    console.log('主进程回复的消息为：', data)
})
```

**主进程 index.js**
```bash
const { ipcMain } = require('electron');
# 创建一个监听频道
ipcMain.on('test', (event, data) => {
    # 主进程拿到之后，和渲染进程回复
    try {
        console.log(data, '主进程')
        # 回复渲染进程
        event.reply('data-res', '主进程已经收到消息了')
    } catch(err){}
})
```

## 2.渲染进程之间的通信
window2给window1通信

### index.js
主进程
**创建窗口**
```bash
const {app, BrowserWindow, protocol} = require('electron');
const winRef = [] # 存储所有的窗口实例
const createWindow = (url) => {
    # 创建的窗口实例对象
    const win = new BrowserWindow({ 
        width: 600,
        height: 800,
        webPreferences: {
            nodeIntegration: true, # 运行在渲染进程（在窗口）使用nodejs
            contextIsolation: false, # 关闭上下文隔离
            webviewTag: true
        }
    })
    # 加载文件
    win.loadURL(url)
    return win
}

# whenReady生命周期方法，会在electron完成应用初始化后调用
# 返回一个promise
app.whenReady().then(() => {
    # 拼接url
    const url1 = url.format({
        protocol: 'file',
        pathname: path.join(__dirname, 'window1/window.html')
    })

    const url2 = url.format({
        protocol: 'file',
        pathname: path.join(__dirname, 'window2/window.html')
    })
    winRef.push(createWindow(url1))
    winRef.push(createWindow(url2))
})
```

**监听页面注册事件**
```bash
# 记录消息通道，也就是记录窗口进程要注册的事件
const messageChannelRecord = {}

/**
 * 
 * @param {*} channel 窗口进程中要注册的事件
 * @param {*} webContentId 窗口对应的id
 */
function registerChannel (channel, webContentId) {
    if (messageChannelRecord[channel] !== undefined) {
        #如果进入这里，说明当前channel注册过了
        # 接下来判断当前窗口是否注册过
        let alreadyRegister = false
        for(let i = 0; i < messageChannelRecord[channel].length; i++) {
            if(messageChannelRecord[channel][i] === webContentId) {
                alreadyRegister = true
                break
            }
        }
        # 只需要根据alreadyRegister的来判断是否需要注册
        if (!alreadyRegister) {
            messageChannelRecord[channel].push(webContentId);
        }
    } else {
        # 没有注册
        # 最终的channel数据结构是这样的；
        # {
        #   action: [1, 2]
        # }
        messageChannelRecord[channel] = [webContentId]
    }
}
# window1的js直接发送给主进程registerChannelEvent事件
ipcMain.on('registerChannelEvent', (event, channel) => {
    try{
        registerChannel(channel, event.sender.id)
    }catch(err) {
        console.log(err);
    }
})
```

**监听window2发送数据事件**
```bash
/**
 * 
 * @param {*} channel 窗口进程注册的事件
 * @return {*} 返回一个数组，数组中存储的是窗口进程id
 */
function getWebContentsId(channel) {
    return messageChannelRecord[channel] || []
}

/**
 * 
 * @param {*} webContentIds 注册了 channel 事件的窗口 id 数组
 * @param {*} channel 对应的事件
 * @param {*} data 数据
 */
function transText (webContentIds, channel, data) {
    for (let i = 0; i < webContentIds.length; i++) {
        for (let j = 0; j < winRef.length; j++) {
            console.log(winRef[j], 'winRef[j]')
            console.log(winRef[j].webContents, 'winRef[j].webContents')
            
            if (winRef[j].webContents.id === webContentIds[i]) {
                winRef[j].webContents.send(channel, data)
                break;
            }
        }
    }
}
# window2发送按钮触发
ipcMain.on('transTextEvent', (event, channel, data) => {
    try {
        transText(getWebContentsId(channel), channel, data)
    }catch(e) {

    }
})
```

### window2
window2用于传递消息
***html***
```bash
<input type="text" name="content" id="content" placeholder="input something">
<button id="btn">发送</button>
```

**js**
```bash
const {ipcRenderer} = require('electron')

const btn = document.getElementById('btn');
const content = document.getElementById('content')

btn.addEventListener('click', () => {
    # 将输入框的数据发送给主进程
    # 回头在主进程需要有这个transTextEvent的监听事件
    ipcRenderer.send(
        'transTextEvent', 
        'action', 
        content.value
    )
})
```

### window1
window1用于接收信息
**html**
```bash
接收窗口2传递过来的数据
当前数据为：<span id="content"></span>
```

**js**
```bash
const {ipcRenderer} = require('electron')

const spanCotent = document.getElementById('content')

ipcRenderer.on('action', (evnet, data) => {
    # data 就是主进程给我传过的数据
    spanCotent.innerHTML = data
})

# 接下来，我们要将我们监听的action事件注册到主进程中
ipcRenderer.send('registerChannelEvent', "action")
```

## 3.使用消息端口通信
### 渲染进程的 MessageChannel 方法
渲染进程向主进程通信

**渲染进程js**
```bash
const { ipcRenderer } = require('electron');
const {port1, port2} = new MessageChannel();

// 接下来需要将port2传递给主进程
// 这里通过ipc进行传递
/**
 * 通道名，
 *  传递的参数
 * 传递端口数据
 */
ipcRenderer.postMessage('port', null, [port2])

port1.onmessage = (event) => {
    document.getElementById('content').innerHTML = event.data
}

document.getElementById('btn').addEventListener('click', () => {
    // 向主进程发消息
    port1.postMessage('hello world')
    
})
```

**主进程js**
```bash
const {app, BrowserWindow, ipcMain} = require('electron')

const createWindow = () => {
    const win = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
        }
    })

    win.loadFile('window/index.html')
}

app.whenReady().then(() => {
    createWindow()
})

ipcMain.on('port', (event) => {
    // 拿到渲染进程给我传递过来port2
    const [port] = event.ports
    port.on('message', (message) => {
        console.log('渲染进程传递的信息：', message.data)
        port.postMessage('asdfasdfsadfasdfasdfasdfasdasdfasdf' )
    })
    // 接下来两者可以开始通信了
    port.start();
})
```

### 主进程MessageChannelMain方法
**主进程 index.js**
```bash
const {app, BrowserWindow, ipcMain, MessageChannelMain} = require('electron')

const createWindow = () => {
    const win = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false,
        }
    })

    win.loadFile('window/index.html')

    ipcMain.on('request-port', (event) => {
        // 创建通信端口
        const {port1, port2} = new MessageChannelMain()
        // port1 主进程自己用
        // port2 渲染进程用
        event.sender.postMessage('delive-port', null, [port2])

        // 监听渲染进程发送过来的信息
        port1.on('message', (event) => {
            if(event.data === 'start') {
                // 开始进行复杂的数据处理，并将处理结果范围给渲染进程
                simulateDataProcessing(port1)
            }
        })
        port1.start()
    })

}

app.whenReady().then(() => {
    createWindow()
})

/**
 * 模拟复杂的数据结果
 * @param {*} port 
 */
function simulateDataProcessing (port) {
    const interval = setInterval(() => {
        const data = Math.random().toFixed(2)
        port.postMessage(data)
    }, 1000)

    port.on('close', () => {
        clearInterval(interval)
        port.close()
    })
}
```

**window.html**
```bash
<h1>数据分析结果</h1>
<button id="startBtn">开始接收数据</button>
<button id="stopBtn">停止接收数据</button>
<div id="data-display">等待数据中。。。。</div>
<script src="index.js"></script>
```
**window.js**
```bash
const { ipcRenderer } = require('electron')

let port = null // 存住主进程传过来的端口
const dataDisplayDOM = document.getElementById('data-display')

// 渲染进程监听一个名为：delive-port 事件
// 然后主进程会发送这个事件，通过端口传过来
ipcRenderer.on('delive-port', (event) => {
    // 拿到了主进程的端口，就可以通信了
    port = event.ports[0]
    // 接下来给主进程发送信息
    port.postMessage('start')
    port.onmessage = (event) => {
        dataDisplayDOM.textContent = event.data
    }
})


document.getElementById("startBtn").addEventListener('click', () => {
    // 现在端口的生产不是在渲染进程，而是在主进程
    // 因此这里我们请求进程把端口发过来
    ipcRenderer.postMessage('request-port', null, [])
})

document.getElementById('stopBtn').addEventListener('click', () => {
    port.close()
    dataDisplayDOM.textContent = '请等待。。。'
    port = null
})
```