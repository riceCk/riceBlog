---
title: 3.窗口基础知识
categories: Electron
tags: Electron
date: 2024-01-13 09:47:00
---

# 窗口

几乎所有包含图形界面的操作系统都是以窗口为基础构建各自的用户界面的。系统内小到一个计算器，大到一个复杂的业务系统，都是基于窗口而创建的。如果开发人员要开发一个有良好用户体验的 *GUI* 应用，势必会在窗口的控制上下足功夫。

Electron 中的窗口由 BrowserWindow 对象来创建，可以配置的属性多达几十个，这里我们将介绍一些比较常用的属性，以及一些比较常见的需求。

主要包含以下内容：

- 窗口相关配置
- 组合窗口
- 窗口的层级

## 窗口相关配置
这块基本上都是传递的BrowserWindow的配置项；
**基础属性**

- maxWidth：设置窗口的最大宽度
- minWidth：设置窗口的最小宽度
- maxHeight：设置窗口的最大高度
- minHeight：设置窗口的最小高度
- resizeable：是否可以改变大小，当设置 resizeable 为 false 之后，代表不可缩放，前面所设置的 maxWidth ... 这些就没有意义了
- moveable：是否可以移动

**窗口位置**

默认窗口出现在屏幕的位置是在正中间，但是我们可以通过 x、y 属性来控制窗口出现在屏幕的位置

- x：控制窗口在屏幕的横向坐标
- y：控制窗口在屏幕的纵向坐标

**标题栏文本和图标**

关于窗口的标题栏，实际上是可以在多个地方设置的。

既然可以在多个地方进行设置，那么这里自然会涉及到一个优先级的问题。优先级从高到低依次：

- HTML文档的 title
- BrowserWindow 里面的 title 属性
- package.json 里面的 name
- Electron 默认值：Electron

除了标题栏文本，我们还可以设置对应的图标：

- icon：设置标题栏的图标，一般来讲是 ico 格式

```js
// 创建窗口方法
const createWindow = () => {
  const win = new BrowserWindow({
    // ...
    icon: path.join(__dirname, "logo.ico")
  });

  win.loadFile("window/index.html");
};
```

**标题栏、菜单栏和边框**

默认我们所创建的窗口，是有标题栏、菜单栏以及边框的，不过这个也是能够控制的。通过 frame 配置项来决定是否要显示。

- frame：true/false 默认值是 true

## 组合窗口

桌面应用有些时候是有多个窗口的，多个窗口彼此之间是相互独立，也就是说，假设我关闭了一个窗口，对另外一个窗口是没有影响的。

但是在有一些场景中，多个窗口之间存在一定程度的联动，例如两个窗口存在父窗口和子窗口之间的关系，父窗口关闭之后，子窗口也一并被关闭掉了。

在 Electron 中，类似这样的需求可以非常简单的被实现，Electron 提供了父子窗口的概念，通过 parent 来指定一个窗口的父窗口。

当窗口之间形成了父子关系之后，两个窗口在行为上就会有一定的联系：

- 子窗口可以相对于父窗口的位置来定位
- 父窗口在移动的时候，子窗口也跟着移动
- 父窗口关闭了，子窗口也应该一并被关闭掉
- .....

### 关联父子窗口栗子
```bash
// 创建窗口
const createWindow = (config, parent) => {
    // 创建的窗口实例对象
    const win = new BrowserWindow({ 
        width: config.width,
        height: config.height,
        parent: parent || null, // 传入父窗口实例
        webPreferences: {
            nodeIntegration: true, // 运行在渲染进程（在窗口）使用nodejs
            contextIsolation: false, // 关闭上下文隔离
            webviewTag: true
        }
    })
    // 加载文件
    win.loadURL(config.file)
    return win
}

// whenReady生命周期方法，会在electron完成应用初始化后调用
// 返回一个promise
app.whenReady().then(() => {
    parentWin = createWindow(win1Config)
    chileWin = createWindow(win2Config, parentWin)
})
```

### 相对父窗口进行子窗口定位 栗子
```bash
app.whenReady().then(() => {
    parentWin = createWindow(win1Config)
    chileWin = createWindow(win2Config, parentWin)
    // 获取父窗口的位置信息
    const {x, y, width} = parentWin.getBounds()
    console.log(x, y, width);
    // 根据父窗口的位置信息计算子窗口应该在的位置
    const chileWinX = x + width + 15
    const chileWinY = y;
    // 设置子串口位置
    chileWin.setPosition(chileWinX, chileWinY);
    // 显示子窗口
    chileWin.show();
})
```

## 窗口的层级

## 窗口的层级

当我们创建多个窗口的时候，默认情况下最后面创建的窗口，就在越上层。但是如果两个窗口是独立的话，那么当用户点击对应的窗口的时候，被点击的窗口会处于最上层。

但是在某些场景下，我们就是需要置顶某一些窗口，有两种方式可以办到：

- alwaysOnTop：true/false
  - 该配置属性虽然也能够置顶窗口，但是没有办法进行更新细粒度的设置
- window.setAlwaysOnTop(flag, level, relativeLevel)：该方法可以进行一个更细粒度的控制
  - flag：一个布尔值，用于设置窗口是否始终位于顶部。如果为 true，窗口将始终保持在最前面；如果为 false，则取消这一设置
  - level（可选）：一个字符串，指定窗口相对于其他窗口的层次。常用的值包括 'normal', 'floating', 'torn-off-menu', 'modal-panel', 'main-menu', 'status', 'pop-up-menu', 'screen-saver' 等。这个参数在不同的操作系统上可能会有不同的行为。
  - relativeLevel（可选）：一个整数，用于在设置了 level 的情况下进一步微调窗口层次。

**alwaysOnTop 举个栗子**
```bash
const createWindow = (config, parent) => {
    const win = new BrowserWindow({ 
        ... #置顶窗口
        alwaysOnTop: config.alwaysOnTop || false,
    })
    win.loadURL(config.file)
}
```

**setAlwaysOnTop 举个栗子**
```bash
app.whenReady().then(() => {
    parentWin = createWindow(win1Config)
    # pop-up-menu 层级比底部菜单栏还要高权重
    parentWin.setAlwaysOnTop(true, 'pop-up-menu')
})
```

# 多窗口管理
实际上要对多窗口进行管理，原理就是主要将所有窗口的应用存在一个map里，之后对某个窗口进行操作，直接从map里面取对应的窗口引用即可
```bash
# 改map结构存储所有窗口引用
const winMap = new Map()

const createWindow = (config) => {
    ...
    winMap.set(config.name, win) # 关键代码

    if (config.name === 'win2') {
        win.on('close', (e) => {
            # 阻止默认行为，即阻止窗口的真实关闭
            e.preventDefault();
            # 隐藏窗口
            win.hide()
        })
    }
}

ipcMain.on('openWindow', (_, data) => {
    # 根据传过来的窗口名字找到对应窗口
    winMap.get(data).show()
})
ipcMain.on('closeWindow', (_, data) => {
    # 关闭窗口，是隐藏窗口
    winMap.get(data).hide()
})
```
很多时间需要对多个窗口进行分组，这个时候简单的更改map的结构
首先在窗口配置方面，新增一个group属性，表明该窗口是哪个分组的
```bash
# 窗口1的配置
const win1Config = {
    name: 'win1',
    width: 600,
    height: 400,
    show: true,
    group: 'group1', # 新增属性
    file: url.format({
        protocol: 'file',
        pathname: path.join(__dirname, 'window/index.html')
    })
}
```
第二步，创建窗口后，从map里面获取对应分组的数据，这里又分为两种情况
* 该分组名下的数组存在：直接将该窗口引用放入改分组的数组里面
* 该分组不存在的时候：创建新的数组，将该窗口放入新的分组中

**核心代码**
```bash
const createWindow = (config) => {
    ....
    win.loadFile(config.file);
    # 接下来根据分组，将窗口应用存储到map中
    if (config.group) {
        # 根据分组名，先找到对象窗口数组
        let groupArr = winMap.get(config.group)
        if (groupArr) {
            groupArr.push(win)
        } else {
            groupArr = [win]
        }
        # 接下俩更新map
        winMap.set(config.group, groupArr)
        console.log('windowMap', winMap)
    }
    return win
}
```

**窗口关闭操作时，还需要将关闭的窗口实例从map结构中移除掉**
```bash
 # 接下来还需要监听窗口关闭事件，当窗口关闭的时将其map结构中移除
win.on('close', () => {
    groupArr = winMap.get(config.group);
    groupArr = groupArr.filter(item => item != win);
    # 更新
    winMap.set(config.group, groupArr)
    # 如果分组项没有窗口了，移除map结构
    if (groupArr.length === 0) {
        winMap.delete(config.group)
    }
    console.log('windowMap', winMap)
})
```