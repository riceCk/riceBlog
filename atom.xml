<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>riceCK</title>
  
  <subtitle>欢迎来到帅比凯的博客</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-08-21T06:20:36.747Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>陈凯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2024/08/21/%E6%A0%87%E7%AD%BE/hello-world/"/>
    <id>http://yoursite.com/2024/08/21/%E6%A0%87%E7%AD%BE/hello-world/</id>
    <published>2024-08-21T06:20:36.747Z</published>
    <updated>2024-08-21T06:20:36.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客的开设只是希望能够将自己在前端学习的过程记录下来，成为一种永恒，以便于今后的学习和深造。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>欢迎来到陈凯的Blog! 2018年5月5号的今天，我的博客正式开始启动了，我在这里致敬每天奋斗在键盘第一线的你们。谢谢你们为我们创造出这个绚丽缤纷的世界。<br>接触前端也快半年了，不可否认到现在仍然只是一个菜鸟。学习编程是一件非常开心的事件，容易沦陷在代码逻辑中不可自拔，当然也会有时常想要砸显示屏的冲动的。人生不只是眼前的苟且，在前端的道路上，我可能成为不了所有人心中优秀的程序员，但是我会努力让今天自己比昨天跟优秀，让明天更有自信。</p><h2 id="广度学习与深度学习及二八法则的学习准则"><a href="#广度学习与深度学习及二八法则的学习准则" class="headerlink" title="广度学习与深度学习及二八法则的学习准则"></a>广度学习与深度学习及二八法则的学习准则</h2><p>&emsp;&emsp;曾经被人问道：怎么规划<code>广度学习</code>与<code>深度学习</code>，在经过一定的深思以及总结前段时间时间的学习状态之后，略微激发出一点小感受。<br>&emsp;&emsp;就读大三的我在刚踏入前端的路程过程中，结合市场的发展，有幸遇到机缘的引领，开始从html、css、js底层到h5、css3、es6，从jq、Bootstrap到webpack、gulp再到vue、react等框架的学习掌握，从一个纯小白慢慢的开始踏入前端的门槛上，本着就是<code>广度学习</code>的方法，在有限的时间内慢慢开辟出前端的道路，当然这并不意味这偷工减料的自我麻痹，<code>广度学习</code>和<code>深度学习</code>也是相互相成的，只在在特定的时间段偏向特定的方法，所以即说的<code>广度学习</code>，但也缺少不了深度的基础知识的巩固。<br>&emsp;&emsp;从2018年1月开始到今8月份的我仍然在着重<code>广度学习</code>策略，那有人问了我什么时候，侧重<code>深度学习</code>，我的理解是，当你真正遇到伯乐开始，互联网的有句老话–<code>二八法则</code>,<strong>工作中的百分之八十问题，只需要学习的百分之二十知识就可以满足</strong>，在我<code>广度学习</code>的过程中就是为了全面的掌握市场所求的所用的那百分之二十知识，当然之比多绝不小，难道这就够了？显然不可能的，二八法则还有后话，<strong>但是工作中剩下的百分之二十的问题，就是需要你百分之八十的知识才能解决</strong>，而这百分之八十的知识就是<code>广度学习</code>的重点，在进入公司之后，着重从底层到源码，从需求到框架的深度挖掘，已扎实自己的利器。<br>&emsp;&emsp;这既是我现在所能高效学习的计划，如果有人问为什么不一开始就<code>深度学习</code>？那我只能说我，只是一介凡人，纵使有着高度的编程爱好，但一味圣母玛利亚学习法样样求精，在相同时间内，从时间到精力上是很难办到的。<br>&emsp;&emsp;如果有人觉得我学习的动力不纯粹，可能只是想找一份好工作，我想说的是，<strong>在我高度精力学习的状态下，没有极致对编程的热爱是绝对不可能现实的，有点功利心只会是学习过程的催化剂。</strong></p><p><strong>我相信，未来的自己，绝对会感谢，现在的自己，在对的年纪做对了的事</strong></p><h2 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h2><p>今天！2020年12月17日，两年后的今天从家乡来到了南京，两年的时光改变了很多，转眼回首，初心逐渐丢失，对编程的热爱趋于平淡，理想再次模糊，平淡无奇而又浑浑噩噩。<br>改变就从今天开始，时间管理，下班两小时原则，找回曾经失去的热情，为了更好地自己努力前行；减肥、学习、自我的提升，为了遇见未来更好地ta和自己做准备。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客的开设只是希望能够将自己在前端学习的过程记录下来，成为一种永恒，以便于今后的学习和深造。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>3.窗口基础知识</title>
    <link href="http://yoursite.com/2024/01/13/Electron/3_%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2024/01/13/Electron/3_%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-01-13T01:47:00.000Z</published>
    <updated>2024-10-15T10:15:37.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><p>几乎所有包含图形界面的操作系统都是以窗口为基础构建各自的用户界面的。系统内小到一个计算器，大到一个复杂的业务系统，都是基于窗口而创建的。如果开发人员要开发一个有良好用户体验的 <em>GUI</em> 应用，势必会在窗口的控制上下足功夫。</p><p>Electron 中的窗口由 BrowserWindow 对象来创建，可以配置的属性多达几十个，这里我们将介绍一些比较常用的属性，以及一些比较常见的需求。</p><p>主要包含以下内容：</p><ul><li>窗口相关配置</li><li>组合窗口</li><li>窗口的层级</li></ul><h2 id="窗口相关配置"><a href="#窗口相关配置" class="headerlink" title="窗口相关配置"></a>窗口相关配置</h2><p>这块基本上都是传递的BrowserWindow的配置项；<br><strong>基础属性</strong></p><ul><li>maxWidth：设置窗口的最大宽度</li><li>minWidth：设置窗口的最小宽度</li><li>maxHeight：设置窗口的最大高度</li><li>minHeight：设置窗口的最小高度</li><li>resizeable：是否可以改变大小，当设置 resizeable 为 false 之后，代表不可缩放，前面所设置的 maxWidth … 这些就没有意义了</li><li>moveable：是否可以移动</li></ul><p><strong>窗口位置</strong></p><p>默认窗口出现在屏幕的位置是在正中间，但是我们可以通过 x、y 属性来控制窗口出现在屏幕的位置</p><ul><li>x：控制窗口在屏幕的横向坐标</li><li>y：控制窗口在屏幕的纵向坐标</li></ul><p><strong>标题栏文本和图标</strong></p><p>关于窗口的标题栏，实际上是可以在多个地方设置的。</p><p>既然可以在多个地方进行设置，那么这里自然会涉及到一个优先级的问题。优先级从高到低依次：</p><ul><li>HTML文档的 title</li><li>BrowserWindow 里面的 title 属性</li><li>package.json 里面的 name</li><li>Electron 默认值：Electron</li></ul><p>除了标题栏文本，我们还可以设置对应的图标：</p><ul><li>icon：设置标题栏的图标，一般来讲是 ico 格式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建窗口方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createWindow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">icon</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;logo.ico&quot;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  win.<span class="title function_">loadFile</span>(<span class="string">&quot;window/index.html&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>标题栏、菜单栏和边框</strong></p><p>默认我们所创建的窗口，是有标题栏、菜单栏以及边框的，不过这个也是能够控制的。通过 frame 配置项来决定是否要显示。</p><ul><li>frame：true/false 默认值是 true</li></ul><h2 id="组合窗口"><a href="#组合窗口" class="headerlink" title="组合窗口"></a>组合窗口</h2><p>桌面应用有些时候是有多个窗口的，多个窗口彼此之间是相互独立，也就是说，假设我关闭了一个窗口，对另外一个窗口是没有影响的。</p><p>但是在有一些场景中，多个窗口之间存在一定程度的联动，例如两个窗口存在父窗口和子窗口之间的关系，父窗口关闭之后，子窗口也一并被关闭掉了。</p><p>在 Electron 中，类似这样的需求可以非常简单的被实现，Electron 提供了父子窗口的概念，通过 parent 来指定一个窗口的父窗口。</p><p>当窗口之间形成了父子关系之后，两个窗口在行为上就会有一定的联系：</p><ul><li>子窗口可以相对于父窗口的位置来定位</li><li>父窗口在移动的时候，子窗口也跟着移动</li><li>父窗口关闭了，子窗口也应该一并被关闭掉</li><li>…..</li></ul><h3 id="关联父子窗口栗子"><a href="#关联父子窗口栗子" class="headerlink" title="关联父子窗口栗子"></a>关联父子窗口栗子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建窗口</span><br><span class="line">const createWindow = (config, parent) =&gt; &#123;</span><br><span class="line">    // 创建的窗口实例对象</span><br><span class="line">    const win = new BrowserWindow(&#123; </span><br><span class="line">        width: config.width,</span><br><span class="line">        height: config.height,</span><br><span class="line">        parent: parent || null, // 传入父窗口实例</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">            nodeIntegration: <span class="literal">true</span>, // 运行在渲染进程（在窗口）使用nodejs</span><br><span class="line">            contextIsolation: <span class="literal">false</span>, // 关闭上下文隔离</span><br><span class="line">            webviewTag: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 加载文件</span><br><span class="line">    win.loadURL(config.file)</span><br><span class="line">    <span class="built_in">return</span> win</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// whenReady生命周期方法，会在electron完成应用初始化后调用</span><br><span class="line">// 返回一个promise</span><br><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    parentWin = createWindow(win1Config)</span><br><span class="line">    chileWin = createWindow(win2Config, parentWin)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="相对父窗口进行子窗口定位-栗子"><a href="#相对父窗口进行子窗口定位-栗子" class="headerlink" title="相对父窗口进行子窗口定位 栗子"></a>相对父窗口进行子窗口定位 栗子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    parentWin = createWindow(win1Config)</span><br><span class="line">    chileWin = createWindow(win2Config, parentWin)</span><br><span class="line">    // 获取父窗口的位置信息</span><br><span class="line">    const &#123;x, y, width&#125; = parentWin.getBounds()</span><br><span class="line">    console.log(x, y, width);</span><br><span class="line">    // 根据父窗口的位置信息计算子窗口应该在的位置</span><br><span class="line">    const chileWinX = x + width + <span class="number">15</span></span><br><span class="line">    const chileWinY = y;</span><br><span class="line">    // 设置子串口位置</span><br><span class="line">    chileWin.setPosition(chileWinX, chileWinY);</span><br><span class="line">    // 显示子窗口</span><br><span class="line">    chileWin.show();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="窗口的层级"><a href="#窗口的层级" class="headerlink" title="窗口的层级"></a>窗口的层级</h2><h2 id="窗口的层级-1"><a href="#窗口的层级-1" class="headerlink" title="窗口的层级"></a>窗口的层级</h2><p>当我们创建多个窗口的时候，默认情况下最后面创建的窗口，就在越上层。但是如果两个窗口是独立的话，那么当用户点击对应的窗口的时候，被点击的窗口会处于最上层。</p><p>但是在某些场景下，我们就是需要置顶某一些窗口，有两种方式可以办到：</p><ul><li>alwaysOnTop：true/false<ul><li>该配置属性虽然也能够置顶窗口，但是没有办法进行更新细粒度的设置</li></ul></li><li>window.setAlwaysOnTop(flag, level, relativeLevel)：该方法可以进行一个更细粒度的控制<ul><li>flag：一个布尔值，用于设置窗口是否始终位于顶部。如果为 true，窗口将始终保持在最前面；如果为 false，则取消这一设置</li><li>level（可选）：一个字符串，指定窗口相对于其他窗口的层次。常用的值包括 ‘normal’, ‘floating’, ‘torn-off-menu’, ‘modal-panel’, ‘main-menu’, ‘status’, ‘pop-up-menu’, ‘screen-saver’ 等。这个参数在不同的操作系统上可能会有不同的行为。</li><li>relativeLevel（可选）：一个整数，用于在设置了 level 的情况下进一步微调窗口层次。</li></ul></li></ul><p><strong>alwaysOnTop 举个栗子</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const createWindow = (config, parent) =&gt; &#123;</span><br><span class="line">    const win = new BrowserWindow(&#123; </span><br><span class="line">        ... <span class="comment">#置顶窗口</span></span><br><span class="line">        alwaysOnTop: config.alwaysOnTop || <span class="literal">false</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    win.loadURL(config.file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>setAlwaysOnTop 举个栗子</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    parentWin = createWindow(win1Config)</span><br><span class="line">    # pop-up-menu 层级比底部菜单栏还要高权重</span><br><span class="line">    parentWin.setAlwaysOnTop(true, &#x27;pop-up-menu&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="多窗口管理"><a href="#多窗口管理" class="headerlink" title="多窗口管理"></a>多窗口管理</h1><p>实际上要对多窗口进行管理，原理就是主要将所有窗口的应用存在一个map里，之后对某个窗口进行操作，直接从map里面取对应的窗口引用即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改map结构存储所有窗口引用</span></span><br><span class="line">const winMap = new Map()</span><br><span class="line"></span><br><span class="line">const createWindow = (config) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    winMap.<span class="built_in">set</span>(config.name, win) <span class="comment"># 关键代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.name === <span class="string">&#x27;win2&#x27;</span>) &#123;</span><br><span class="line">        win.on(<span class="string">&#x27;close&#x27;</span>, (e) =&gt; &#123;</span><br><span class="line">            <span class="comment"># 阻止默认行为，即阻止窗口的真实关闭</span></span><br><span class="line">            e.preventDefault();</span><br><span class="line">            <span class="comment"># 隐藏窗口</span></span><br><span class="line">            win.hide()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">&#x27;openWindow&#x27;</span>, (_, data) =&gt; &#123;</span><br><span class="line">    <span class="comment"># 根据传过来的窗口名字找到对应窗口</span></span><br><span class="line">    winMap.get(data).show()</span><br><span class="line">&#125;)</span><br><span class="line">ipcMain.on(<span class="string">&#x27;closeWindow&#x27;</span>, (_, data) =&gt; &#123;</span><br><span class="line">    <span class="comment"># 关闭窗口，是隐藏窗口</span></span><br><span class="line">    winMap.get(data).hide()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>很多时间需要对多个窗口进行分组，这个时候简单的更改map的结构<br>首先在窗口配置方面，新增一个group属性，表明该窗口是哪个分组的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口1的配置</span></span><br><span class="line">const win1Config = &#123;</span><br><span class="line">    name: <span class="string">&#x27;win1&#x27;</span>,</span><br><span class="line">    width: 600,</span><br><span class="line">    height: 400,</span><br><span class="line">    show: <span class="literal">true</span>,</span><br><span class="line">    group: <span class="string">&#x27;group1&#x27;</span>, <span class="comment"># 新增属性</span></span><br><span class="line">    file: url.format(&#123;</span><br><span class="line">        protocol: <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">        pathname: path.join(__dirname, <span class="string">&#x27;window/index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第二步，创建窗口后，从map里面获取对应分组的数据，这里又分为两种情况</p><ul><li>该分组名下的数组存在：直接将该窗口引用放入改分组的数组里面</li><li>该分组不存在的时候：创建新的数组，将该窗口放入新的分组中</li></ul><p><strong>核心代码</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const createWindow = (config) =&gt; &#123;</span><br><span class="line">    ....</span><br><span class="line">    win.loadFile(config.file);</span><br><span class="line">    <span class="comment"># 接下来根据分组，将窗口应用存储到map中</span></span><br><span class="line">    <span class="keyword">if</span> (config.group) &#123;</span><br><span class="line">        <span class="comment"># 根据分组名，先找到对象窗口数组</span></span><br><span class="line">        <span class="built_in">let</span> groupArr = winMap.get(config.group)</span><br><span class="line">        <span class="keyword">if</span> (groupArr) &#123;</span><br><span class="line">            groupArr.push(win)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupArr = [win]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 接下俩更新map</span></span><br><span class="line">        winMap.<span class="built_in">set</span>(config.group, groupArr)</span><br><span class="line">        console.log(<span class="string">&#x27;windowMap&#x27;</span>, winMap)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> win</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>窗口关闭操作时，还需要将关闭的窗口实例从map结构中移除掉</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 接下来还需要监听窗口关闭事件，当窗口关闭的时将其map结构中移除</span></span><br><span class="line">win.on(<span class="string">&#x27;close&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    groupArr = winMap.get(config.group);</span><br><span class="line">    groupArr = groupArr.filter(item =&gt; item != win);</span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    winMap.<span class="built_in">set</span>(config.group, groupArr)</span><br><span class="line">    <span class="comment"># 如果分组项没有窗口了，移除map结构</span></span><br><span class="line">    <span class="keyword">if</span> (groupArr.length === 0) &#123;</span><br><span class="line">        winMap.delete(config.group)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(<span class="string">&#x27;windowMap&#x27;</span>, winMap)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;窗口&quot;&gt;&lt;a href=&quot;#窗口&quot; class=&quot;headerlink&quot; title=&quot;窗口&quot;&gt;&lt;/a&gt;窗口&lt;/h1&gt;&lt;p&gt;几乎所有包含图形界面的操作系统都是以窗口为基础构建各自的用户界面的。系统内小到一个计算器，大到一个复杂的业务系统，都是基于窗口而创建的。如果</summary>
      
    
    
    
    <category term="Electron" scheme="http://yoursite.com/categories/Electron/"/>
    
    
    <category term="Electron" scheme="http://yoursite.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>4.应用常见设置</title>
    <link href="http://yoursite.com/2024/01/13/Electron/4_%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2024/01/13/Electron/4_%E5%BA%94%E7%94%A8%E5%B8%B8%E8%A7%81%E8%AE%BE%E7%BD%AE/</id>
    <published>2024-01-13T01:47:00.000Z</published>
    <updated>2024-10-16T08:20:17.517Z</updated>
    
    
    
    
    <category term="Electron" scheme="http://yoursite.com/categories/Electron/"/>
    
    
    <category term="Electron" scheme="http://yoursite.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>2.进程通信</title>
    <link href="http://yoursite.com/2024/01/11/Electron/2_%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2024/01/11/Electron/2_%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2024-01-11T01:47:00.000Z</published>
    <updated>2024-10-13T02:24:48.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主进程和渲染进程通信"><a href="#主进程和渲染进程通信" class="headerlink" title="主进程和渲染进程通信"></a>主进程和渲染进程通信</h2><ul><li>主进程和渲染进程之间的通信</li><li>渲染进程彼此之间的通信</li></ul><p>在 Electron 中，已经对应的模块 ipcMain 和 ipcRenderer 来实现这两类进程之间的通信。</p><h3 id="ipcMain模块"><a href="#ipcMain模块" class="headerlink" title="ipcMain模块"></a>ipcMain模块</h3><p><strong>ipcMain.on(channel, listener)</strong></p><ul><li>这个很明显是一个监听事件，on 方法监听 channel 频道所触发的事件</li><li>listener 是一个回调函数，当监听的频道有新消息抵达时，会执行该回调函数<ul><li>listener(event, args…)<ul><li>event 是一个事件对象，event.reply =&gt; 回复渲染进程</li><li>args 是一个参数列表</li></ul></li></ul></li></ul><p><strong>ipcMain.once(channel, listener)：</strong>和上面 on 的区别在于 once 只会监听一次<br><strong>ipcMain.removeListener(channel, listener)：</strong>移除 on 方法所绑定的事件监听。</p><p>具体可以参阅：<a href="https://www.electronjs.org/zh/docs/latest/api/ipc-main">https://www.electronjs.org/zh/docs/latest/api/ipc-main</a></p><h3 id="ipcRenderer模块"><a href="#ipcRenderer模块" class="headerlink" title="ipcRenderer模块"></a>ipcRenderer模块</h3><p>基本上和上面的主进程非常的相似。<br><strong>ipcRenderer.on(channel, listener)</strong></p><ul><li>和上面主进程的 on 方法用法一样</li></ul><p><strong>ipcRenderer.send(channel, …args)</strong></p><ul><li>此方法用于向主进程对应的 channel 频道发送消息。</li><li>注意 send 方法传递的内容是被序列化了的，所以并非所有数据类型都支持</li></ul><p>这两个模块实际上是基于 Node.js 里面 EventEmitter 模块实现的。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> event = <span class="built_in">require</span>(<span class="string">&#x27;./event&#x27;</span>);</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;some_event&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>).<span class="property">EventEmitter</span>;</span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听自定义事件</span></span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&quot;some_event&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;事件已触发&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = event;</span><br></pre></td></tr></table></figure><p><strong>ipcRenderer.postMessage(channel, message, [transfer])</strong></p><ul><li>发送消息到主进程，同时可以选择性发送零到多个 MessagePort 对象<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 渲染进程</span><br><span class="line">const &#123; port1, port2 &#125; = new MessageChannel()</span><br><span class="line">ipcRenderer.postMessage(<span class="string">&#x27;port&#x27;</span>, &#123; message: <span class="string">&#x27;hello&#x27;</span> &#125;, [port1])</span><br><span class="line"></span><br><span class="line">// 主进程</span><br><span class="line">ipcMain.on(<span class="string">&#x27;port&#x27;</span>, (e, msg) =&gt; &#123;</span><br><span class="line">  const [port] = e.ports</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码栗子"><a href="#代码栗子" class="headerlink" title="代码栗子"></a>代码栗子</h3><p><strong>渲染进程 window.js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 获取button的DOM节点</span></span><br><span class="line">const btn = document.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment"># 创建一个http请求</span></span><br><span class="line">    const req = http.request(options, (res) =&gt; &#123;</span><br><span class="line">        res.setEncoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        res.on(<span class="string">&#x27;data&#x27;</span>, (data) =&gt; &#123;</span><br><span class="line">            <span class="comment"># 拿到的数据之后，发送给主进程</span></span><br><span class="line">            ipcRenderer.send(<span class="string">&#x27;test&#x27;</span>, data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 发送http请求</span></span><br><span class="line">    req.write(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 请求结束</span></span><br><span class="line">    req.end();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">## 监听主线程回复的信息</span></span><br><span class="line">ipcRenderer.on(<span class="string">&#x27;data-res&#x27;</span>, (event, data) =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;主进程回复的消息为：&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>主进程 index.js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ipcMain &#125; = require(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"><span class="comment"># 创建一个监听频道</span></span><br><span class="line">ipcMain.on(<span class="string">&#x27;test&#x27;</span>, (event, data) =&gt; &#123;</span><br><span class="line">    <span class="comment"># 主进程拿到之后，和渲染进程回复</span></span><br><span class="line">    try &#123;</span><br><span class="line">        console.log(data, <span class="string">&#x27;主进程&#x27;</span>)</span><br><span class="line">        <span class="comment"># 回复渲染进程</span></span><br><span class="line">        event.reply(<span class="string">&#x27;data-res&#x27;</span>, <span class="string">&#x27;主进程已经收到消息了&#x27;</span>)</span><br><span class="line">    &#125; catch(err)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="渲染进程之间的通信"><a href="#渲染进程之间的通信" class="headerlink" title="渲染进程之间的通信"></a>渲染进程之间的通信</h2><p>window2给window1通信</p><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>主进程<br><strong>创建窗口</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow, protocol&#125; = require(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line">const winRef = [] <span class="comment"># 存储所有的窗口实例</span></span><br><span class="line">const createWindow = (url) =&gt; &#123;</span><br><span class="line">    <span class="comment"># 创建的窗口实例对象</span></span><br><span class="line">    const win = new BrowserWindow(&#123; </span><br><span class="line">        width: 600,</span><br><span class="line">        height: 800,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">            nodeIntegration: <span class="literal">true</span>, <span class="comment"># 运行在渲染进程（在窗口）使用nodejs</span></span><br><span class="line">            contextIsolation: <span class="literal">false</span>, <span class="comment"># 关闭上下文隔离</span></span><br><span class="line">            webviewTag: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 加载文件</span></span><br><span class="line">    win.loadURL(url)</span><br><span class="line">    <span class="built_in">return</span> win</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># whenReady生命周期方法，会在electron完成应用初始化后调用</span></span><br><span class="line"><span class="comment"># 返回一个promise</span></span><br><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    # 拼接url</span><br><span class="line">    const url1 = url.format(&#123;</span><br><span class="line">        protocol: &#x27;file&#x27;,</span><br><span class="line">        pathname: path.join(__dirname, &#x27;window1/window.html&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const url2 = url.format(&#123;</span><br><span class="line">        protocol: &#x27;file&#x27;,</span><br><span class="line">        pathname: path.join(__dirname, &#x27;window2/window.html&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    winRef.push(createWindow(url1))</span><br><span class="line">    winRef.push(createWindow(url2))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>监听页面注册事件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录消息通道，也就是记录窗口进程要注册的事件</span></span><br><span class="line">const messageChannelRecord = &#123;&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; channel 窗口进程中要注册的事件</span><br><span class="line"> * @param &#123;*&#125; webContentId 窗口对应的<span class="built_in">id</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> registerChannel (channel, webContentId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (messageChannelRecord[channel] !== undefined) &#123;</span><br><span class="line">        <span class="comment">#如果进入这里，说明当前channel注册过了</span></span><br><span class="line">        <span class="comment"># 接下来判断当前窗口是否注册过</span></span><br><span class="line">        <span class="built_in">let</span> alreadyRegister = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; messageChannelRecord[channel].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(messageChannelRecord[channel][i] === webContentId) &#123;</span><br><span class="line">                alreadyRegister = <span class="literal">true</span></span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 只需要根据alreadyRegister的来判断是否需要注册</span></span><br><span class="line">        <span class="keyword">if</span> (!alreadyRegister) &#123;</span><br><span class="line">            messageChannelRecord[channel].push(webContentId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment"># 没有注册</span></span><br><span class="line">        <span class="comment"># 最终的channel数据结构是这样的；</span></span><br><span class="line">        <span class="comment"># &#123;</span></span><br><span class="line">        <span class="comment">#   action: [1, 2]</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line">        messageChannelRecord[channel] = [webContentId]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># window1的js直接发送给主进程registerChannelEvent事件</span></span><br><span class="line">ipcMain.on(<span class="string">&#x27;registerChannelEvent&#x27;</span>, (event, channel) =&gt; &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        registerChannel(channel, event.sender.id)</span><br><span class="line">    &#125;catch(err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>监听window2发送数据事件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; channel 窗口进程注册的事件</span><br><span class="line"> * @<span class="built_in">return</span> &#123;*&#125; 返回一个数组，数组中存储的是窗口进程<span class="built_in">id</span></span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> getWebContentsId(channel) &#123;</span><br><span class="line">    <span class="built_in">return</span> messageChannelRecord[channel] || []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; webContentIds 注册了 channel 事件的窗口 <span class="built_in">id</span> 数组</span><br><span class="line"> * @param &#123;*&#125; channel 对应的事件</span><br><span class="line"> * @param &#123;*&#125; data 数据</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> transText (webContentIds, channel, data) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; webContentIds.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> j = 0; j &lt; winRef.length; j++) &#123;</span><br><span class="line">            console.log(winRef[j], <span class="string">&#x27;winRef[j]&#x27;</span>)</span><br><span class="line">            console.log(winRef[j].webContents, <span class="string">&#x27;winRef[j].webContents&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (winRef[j].webContents.<span class="built_in">id</span> === webContentIds[i]) &#123;</span><br><span class="line">                winRef[j].webContents.send(channel, data)</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># window2发送按钮触发</span></span><br><span class="line">ipcMain.on(<span class="string">&#x27;transTextEvent&#x27;</span>, (event, channel, data) =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        transText(getWebContentsId(channel), channel, data)</span><br><span class="line">    &#125;catch(e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="window2"><a href="#window2" class="headerlink" title="window2"></a>window2</h3><p>window2用于传递消息<br><strong><em>html</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;content&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;content&quot;</span> placeholder=<span class="string">&quot;input something&quot;</span>&gt;</span><br><span class="line">&lt;button <span class="built_in">id</span>=<span class="string">&quot;btn&quot;</span>&gt;发送&lt;/button&gt;</span><br></pre></td></tr></table></figure></p><p><strong>js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const &#123;ipcRenderer&#125; = require(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line">const btn = document.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">const content = document.getElementById(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment"># 将输入框的数据发送给主进程</span></span><br><span class="line">    <span class="comment"># 回头在主进程需要有这个transTextEvent的监听事件</span></span><br><span class="line">    ipcRenderer.send(</span><br><span class="line">        <span class="string">&#x27;transTextEvent&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;action&#x27;</span>, </span><br><span class="line">        content.value</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="window1"><a href="#window1" class="headerlink" title="window1"></a>window1</h3><p>window1用于接收信息<br><strong>html</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接收窗口2传递过来的数据</span><br><span class="line">当前数据为：&lt;span <span class="built_in">id</span>=<span class="string">&quot;content&quot;</span>&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p><strong>js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const &#123;ipcRenderer&#125; = require(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line">const spanCotent = document.getElementById(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ipcRenderer.on(<span class="string">&#x27;action&#x27;</span>, (evnet, data) =&gt; &#123;</span><br><span class="line">    <span class="comment"># data 就是主进程给我传过的数据</span></span><br><span class="line">    spanCotent.innerHTML = data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，我们要将我们监听的action事件注册到主进程中</span></span><br><span class="line">ipcRenderer.send(<span class="string">&#x27;registerChannelEvent&#x27;</span>, <span class="string">&quot;action&quot;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="使用消息端口通信"><a href="#使用消息端口通信" class="headerlink" title="使用消息端口通信"></a>使用消息端口通信</h2><h3 id="渲染进程的-MessageChannel-方法"><a href="#渲染进程的-MessageChannel-方法" class="headerlink" title="渲染进程的 MessageChannel 方法"></a>渲染进程的 MessageChannel 方法</h3><p>渲染进程向主进程通信</p><p><strong>渲染进程js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ipcRenderer &#125; = require(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line">const &#123;port1, port2&#125; = new MessageChannel();</span><br><span class="line"></span><br><span class="line">// 接下来需要将port2传递给主进程</span><br><span class="line">// 这里通过ipc进行传递</span><br><span class="line">/**</span><br><span class="line"> * 通道名，</span><br><span class="line"> *  传递的参数</span><br><span class="line"> * 传递端口数据</span><br><span class="line"> */</span><br><span class="line">ipcRenderer.postMessage(<span class="string">&#x27;port&#x27;</span>, null, [port2])</span><br><span class="line"></span><br><span class="line">port1.onmessage = (event) =&gt; &#123;</span><br><span class="line">    document.getElementById(<span class="string">&#x27;content&#x27;</span>).innerHTML = event.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    // 向主进程发消息</span><br><span class="line">    port1.postMessage(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>主进程js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow, ipcMain&#125; = require(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line">const createWindow = () =&gt; &#123;</span><br><span class="line">    const win = new BrowserWindow(&#123;</span><br><span class="line">        width: 800,</span><br><span class="line">        height: 600,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">            nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">            contextIsolation: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    win.loadFile(<span class="string">&#x27;window/index.html&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipcMain.on(&#x27;port&#x27;, (event) =&gt; &#123;</span><br><span class="line">    // 拿到渲染进程给我传递过来port2</span><br><span class="line">    const [port] = event.ports</span><br><span class="line">    port.on(&#x27;message&#x27;, (message) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;渲染进程传递的信息：&#x27;, message.data)</span><br><span class="line">        port.postMessage(&#x27;asdfasdfsadfasdfasdfasdfasdasdfasdf&#x27; )</span><br><span class="line">    &#125;)</span><br><span class="line">    // 接下来两者可以开始通信了</span><br><span class="line">    port.start();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="主进程MessageChannelMain方法"><a href="#主进程MessageChannelMain方法" class="headerlink" title="主进程MessageChannelMain方法"></a>主进程MessageChannelMain方法</h3><p><strong>主进程 index.js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow, ipcMain, MessageChannelMain&#125; = require(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line">const createWindow = () =&gt; &#123;</span><br><span class="line">    const win = new BrowserWindow(&#123;</span><br><span class="line">        width: 800,</span><br><span class="line">        height: 600,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">            nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">            contextIsolation: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    win.loadFile(<span class="string">&#x27;window/index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    ipcMain.on(<span class="string">&#x27;request-port&#x27;</span>, (event) =&gt; &#123;</span><br><span class="line">        // 创建通信端口</span><br><span class="line">        const &#123;port1, port2&#125; = new MessageChannelMain()</span><br><span class="line">        // port1 主进程自己用</span><br><span class="line">        // port2 渲染进程用</span><br><span class="line">        event.sender.postMessage(<span class="string">&#x27;delive-port&#x27;</span>, null, [port2])</span><br><span class="line"></span><br><span class="line">        // 监听渲染进程发送过来的信息</span><br><span class="line">        port1.on(<span class="string">&#x27;message&#x27;</span>, (event) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(event.data === <span class="string">&#x27;start&#x27;</span>) &#123;</span><br><span class="line">                // 开始进行复杂的数据处理，并将处理结果范围给渲染进程</span><br><span class="line">                simulateDataProcessing(port1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        port1.start()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 模拟复杂的数据结果</span><br><span class="line"> * @param &#123;*&#125; port </span><br><span class="line"> */</span><br><span class="line">function simulateDataProcessing (port) &#123;</span><br><span class="line">    const interval = setInterval(() =&gt; &#123;</span><br><span class="line">        const data = Math.random().toFixed(<span class="number">2</span>)</span><br><span class="line">        port.postMessage(data)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    port.on(&#x27;close&#x27;, () =&gt; &#123;</span><br><span class="line">        clearInterval(interval)</span><br><span class="line">        port.close()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>window.html</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;数据分析结果&lt;/h1&gt;</span><br><span class="line">&lt;button <span class="built_in">id</span>=<span class="string">&quot;startBtn&quot;</span>&gt;开始接收数据&lt;/button&gt;</span><br><span class="line">&lt;button <span class="built_in">id</span>=<span class="string">&quot;stopBtn&quot;</span>&gt;停止接收数据&lt;/button&gt;</span><br><span class="line">&lt;div <span class="built_in">id</span>=<span class="string">&quot;data-display&quot;</span>&gt;等待数据中。。。。&lt;/div&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;index.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><strong>window.js</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ipcRenderer &#125; = require(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> port = null // 存住主进程传过来的端口</span><br><span class="line">const dataDisplayDOM = document.getElementById(<span class="string">&#x27;data-display&#x27;</span>)</span><br><span class="line"></span><br><span class="line">// 渲染进程监听一个名为：delive-port 事件</span><br><span class="line">// 然后主进程会发送这个事件，通过端口传过来</span><br><span class="line">ipcRenderer.on(<span class="string">&#x27;delive-port&#x27;</span>, (event) =&gt; &#123;</span><br><span class="line">    // 拿到了主进程的端口，就可以通信了</span><br><span class="line">    port = event.ports[0]</span><br><span class="line">    // 接下来给主进程发送信息</span><br><span class="line">    port.postMessage(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    port.onmessage = (event) =&gt; &#123;</span><br><span class="line">        dataDisplayDOM.textContent = event.data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">&quot;startBtn&quot;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    // 现在端口的生产不是在渲染进程，而是在主进程</span><br><span class="line">    // 因此这里我们请求进程把端口发过来</span><br><span class="line">    ipcRenderer.postMessage(<span class="string">&#x27;request-port&#x27;</span>, null, [])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">document.getElementById(<span class="string">&#x27;stopBtn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, () =&gt; &#123;</span><br><span class="line">    port.close()</span><br><span class="line">    dataDisplayDOM.textContent = <span class="string">&#x27;请等待。。。&#x27;</span></span><br><span class="line">    port = null</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主进程和渲染进程通信&quot;&gt;&lt;a href=&quot;#主进程和渲染进程通信&quot; class=&quot;headerlink&quot; title=&quot;主进程和渲染进程通信&quot;&gt;&lt;/a&gt;主进程和渲染进程通信&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;主进程和渲染进程之间的通信&lt;/li&gt;
&lt;li&gt;渲染进程彼此之间的</summary>
      
    
    
    
    <category term="Electron" scheme="http://yoursite.com/categories/Electron/"/>
    
    
    <category term="Electron" scheme="http://yoursite.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>1.Electron基本介绍</title>
    <link href="http://yoursite.com/2024/01/10/Electron/1_%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2024/01/10/Electron/1_%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-01-10T01:47:00.000Z</published>
    <updated>2024-10-13T02:24:59.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建你的应用程序"><a href="#创建你的应用程序" class="headerlink" title="创建你的应用程序"></a>创建你的应用程序</h2><h3 id="1-1-使用脚手架创建"><a href="#1-1-使用脚手架创建" class="headerlink" title="1.1 使用脚手架创建"></a>1.1 使用脚手架创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-electron-app &amp;&amp; <span class="built_in">cd</span> my-electron-app</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p><strong>你的 package.json 文件应该像这样：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-electron-app&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Hello World!&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Jane Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>然后，将 electron 包安装到应用的开发依赖中。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev electron</span><br></pre></td></tr></table></figure></p><p>最后，您希望能够执行 Electron 如下所示，在您的 package.json配置文件中的scripts字段下增加一条start命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;electron .&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-创建页面"><a href="#1-2-创建页面" class="headerlink" title="1.2 创建页面"></a>1.2 创建页面</h3><p>创建index.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">head</span>&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Security-Policy&quot;</span> content=<span class="string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">    We are using Node.js &lt;span <span class="built_in">id</span>=<span class="string">&quot;node-version&quot;</span>&gt;&lt;/span&gt;,</span><br><span class="line">    Chromium &lt;span <span class="built_in">id</span>=<span class="string">&quot;chrome-version&quot;</span>&gt;&lt;/span&gt;,</span><br><span class="line">    and Electron &lt;span <span class="built_in">id</span>=<span class="string">&quot;electron-version&quot;</span>&gt;&lt;/span&gt;.</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="1-3-在窗口中打开您的页面"><a href="#1-3-在窗口中打开您的页面" class="headerlink" title="1.3 在窗口中打开您的页面"></a>1.3 在窗口中打开您的页面</h3><p>创建index.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const &#123;app, BrowserWindow&#125; = require(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"></span><br><span class="line">// 创建窗口</span><br><span class="line">const createWindow = () =&gt; &#123;</span><br><span class="line">    const win = new BrowserWindow(&#123; </span><br><span class="line">        width: 800,</span><br><span class="line">        height: 600</span><br><span class="line">    &#125;)</span><br><span class="line">    // 加载文件</span><br><span class="line">    win.loadFile(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// whenReady生命周期方法，会在electron完成应用初始化后调用</span><br><span class="line">// 返回一个promise</span><br><span class="line">app.whenReady().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="2-1-什么是进程？"><a href="#2-1-什么是进程？" class="headerlink" title="2.1 什么是进程？"></a>2.1 什么是进程？</h3><p>假设我们电脑看作一个工厂，电脑上面可以运行应用程序（浏览器，word,音乐播放器，视频播放器），每个应用程序都可以看作独立的工作区域，这个独立的工作区域就是我们的进程。<br>每个进程都会有独立的内存空间和系统资源，每个进程之间是独立的，这意味没有一个进程的崩溃，影响其他进程</p><h3 id="2-2-什么是线程"><a href="#2-2-什么是线程" class="headerlink" title="2.2 什么是线程"></a>2.2 什么是线程</h3><p>刚才我们将进程比作工厂里面一个独立的工作区域，那么每个工作区域都会有员工，一个独立的工作区域是可以有多个员工的，类似的，<strong>一个进程也可以有多个线程</strong>，线程之间进行协同工作，共享相同的<strong>数据和资源</strong>，线程是操作系统所能调度的最小单位<br><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-12-14-021232.png" alt="image-20231214101232495" style="zoom:40%;" /><br>同样都是线程，其中一条线程能够创建其他6个线程，并且又决定这些线程都能够做什么的能力，那么这些线程就被称为主线程。<br>在一个进程中所拥有的资源，所有的线程都有权利去使用，这个就叫做“进程资源共享”</p><p>理论上来讲，一个应用对应一个进程，但是这并不是绝对的，一些大型应用，在进行架构的深海，会设计为多个进程应用，比较典型的就是Chrome浏览器，一个标签页对应一个进程<br>这样的应用我们称为“多进程应用”，如下图所示</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-12-14-021631.png" alt="image-20231214101630565" style="zoom:50%;" /></p><p>  Electron 是主进程，对应的就是我们应用入口文件的 index.js，该主进程负责的任务有：</p><ul><li>管理整个 Electron 应用程序的生命周期</li><li>访问文件系统以及获取操作系统的各种资源</li><li>处理操作系统发出的各种事件</li><li>创建并管理菜单栏</li><li>创建并管理应用程序窗口</li></ul><p>Electron Helper（Renderer）该进程就是我们窗口所对应的渲染进程。</p><p>假设在任务管理器将该进程关闭掉，我们会发现窗口不再渲染任何的东西，但是应用还存在，窗口也还存在。</p><p>这里就需要说一下，实际上在 Electron 应用中，有一个窗口进程，由窗口进程来创建的窗口，之后才是渲染进程来渲染的页面。这也是为什么我们关闭了渲染进程，但是窗口还存在的原因。</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-12-14-034448.png" alt="image-20231214114447694" style="zoom:50%;" /></p><p>假设我们创建了多个窗口，那么会有多个窗口进程么？</p><p>多个窗口下仍然只有一个窗口进程，由这个窗口进程负责绘制多个窗口，不同的窗口里面会有不同的渲染进程来渲染页面。</p><p>如下图所示：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-12-14-035519.png" alt="image-20231214115519137" style="zoom:50%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建你的应用程序&quot;&gt;&lt;a href=&quot;#创建你的应用程序&quot; class=&quot;headerlink&quot; title=&quot;创建你的应用程序&quot;&gt;&lt;/a&gt;创建你的应用程序&lt;/h2&gt;&lt;h3 id=&quot;1-1-使用脚手架创建&quot;&gt;&lt;a href=&quot;#1-1-使用脚手架创建&quot; class</summary>
      
    
    
    
    <category term="Electron" scheme="http://yoursite.com/categories/Electron/"/>
    
    
    <category term="Electron" scheme="http://yoursite.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>技术面之一简历</title>
    <link href="http://yoursite.com/2023/04/30/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/1.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%B8%80%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2023/04/30/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/1.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%B8%80%E7%AE%80%E5%8E%86/</id>
    <published>2023-04-30T01:48:00.000Z</published>
    <updated>2024-09-18T08:03:07.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何写简历"><a href="#如何写简历" class="headerlink" title="如何写简历"></a>如何写简历</h1><ul><li>个人信息</li><li>教育经历</li><li>专业技能</li><li>工作经历</li><li>项目经历</li><li>博客和开源</li></ul><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><ul><li>必备；姓名、性别、电话、邮箱、籍贯</li><li>年龄可不写（最好写）</li><li>头像无所谓</li></ul><h1 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h1><ul><li>写上最高学历即可</li><li>学校，专业，入学和毕业时间</li></ul><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ul><li>表现出自己的核心竞争力</li><li>内容不要太多，3、5条即可</li><li>太基础的不要写，例如会用vscode</li></ul><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><ul><li>如实写</li><li>写明公司，职位，入职离职时间即可，多写无意</li><li>如果有空窗期，如实写明</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ul><li>写2-4个具体说服力的项目（视工作时间）</li><li>项目描述，技术栈，个人角色</li><li>技巧：可以把别人的项目写上，只要你能hold住</li></ul><h2 id="博客或者开源"><a href="#博客或者开源" class="headerlink" title="博客或者开源"></a>博客或者开源</h2><ul><li>有博客或者开源作品，会让你更有竞争力</li><li>切记：需要真的有内容，不可临时抱佛脚</li><li>可以从现在开始，慢慢积累</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>界面不要太花哨，简洁明了即可</li><li>注意用词，“精通”、“熟练”等慎用</li><li>不可造假，会被拉入黑名单（项目经历那里，不是造假）</li></ul><h1 id="面试前的准备"><a href="#面试前的准备" class="headerlink" title="面试前的准备"></a>面试前的准备</h1><ul><li>看JD，是否需要临时准备一下</li><li>打印纸质简历，带着纸和笔</li></ul><h1 id="项目相关问题"><a href="#项目相关问题" class="headerlink" title="项目相关问题"></a>项目相关问题</h1><h2 id="关于项目面试中可以说必问的问题："><a href="#关于项目面试中可以说必问的问题：" class="headerlink" title="关于项目面试中可以说必问的问题："></a>关于项目面试中可以说必问的问题：</h2><ul><li>所有项目中你印象最深刻的是哪个？为什么</li><li>你在从这个项目中遇到的最大的困难是什么，是怎么解决的</li><li>从一个需求提到上线的整个过程，又觉得不完善的地方，有没有做过改进</li></ul><h2 id="分析应该怎么回答"><a href="#分析应该怎么回答" class="headerlink" title="分析应该怎么回答"></a>分析应该怎么回答</h2><ul><li>印象深刻的可以是一个负责的项目，也可以是之前一个没涉及的领域，第一次带人的也可以，只要有理由就可以了</li><li>最大困难的话可以有一些小小的艺术加工，实际在项目碰到了什么问题，就算当时解决绕过了，也可以自己思考下如果是现在自己会怎么去做，有哪种分案分别优劣是什么，只有逻辑通顺没有破绽，这就是你解决的问题</li></ul><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><blockquote><p><a href="https://gitee.com/dev-edu/frontend-interview-html">HTML</a><br><a href="https://gitee.com/dev-edu/frontend-interview-css">css</a><br><a href="https://gitee.com/dev-edu/frontend-interview-javascript">javascript</a><br><a href="https://gitee.com/dev-edu/frontend-interview-promise">promise</a><br><a href="https://gitee.com/dev-edu/frontend-interview-browser">浏览器</a><br><a href="https://gitee.com/dev-edu/frontend-interview-network">网络</a><br><a href="https://gitee.com/dev-edu/frontend-interview-engineering">工程化</a><br><a href="https://gitee.com/dev-edu/frontend-interview-vue">vue</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何写简历&quot;&gt;&lt;a href=&quot;#如何写简历&quot; class=&quot;headerlink&quot; title=&quot;如何写简历&quot;&gt;&lt;/a&gt;如何写简历&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;个人信息&lt;/li&gt;
&lt;li&gt;教育经历&lt;/li&gt;
&lt;li&gt;专业技能&lt;/li&gt;
&lt;li&gt;工作经历&lt;/li&gt;
</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面试之十代码篇</title>
    <link href="http://yoursite.com/2023/04/30/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/10.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%8D%81%E4%BB%A3%E7%A0%81%E7%AF%87/"/>
    <id>http://yoursite.com/2023/04/30/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/10.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%8D%81%E4%BB%A3%E7%A0%81%E7%AF%87/</id>
    <published>2023-04-30T01:48:00.000Z</published>
    <updated>2024-10-14T03:09:54.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、手写代码"><a href="#一、手写代码" class="headerlink" title="一、手写代码"></a>一、手写代码</h2><h3 id="手写promise（简易版）"><a href="#手写promise（简易版）" class="headerlink" title="手写promise（简易版）"></a>手写promise（简易版）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">    constructor (fn) &#123;</span><br><span class="line">        <span class="comment"># 存储reslove回调函数列表</span></span><br><span class="line">        this.callbacks = [];</span><br><span class="line">        const resolve = (value) =&gt; &#123;</span><br><span class="line">            this.data = value <span class="comment"># 返回值给后面的 .then</span></span><br><span class="line">            <span class="keyword">while</span> (this.callbacks.length) &#123;</span><br><span class="line">                <span class="built_in">let</span> cb = this.callbacks.shift();</span><br><span class="line">                cb(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn(resolve);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">then</span>(onResolvedCallback) &#123;</span><br><span class="line">        <span class="built_in">return</span> new MyPromise(resolve =&gt; &#123;</span><br><span class="line">            this.callbacks.push(() =&gt; &#123;</span><br><span class="line">                const res = onResolvedCallback(this.data);</span><br><span class="line">                if (res instanceof MyPromise) &#123;</span><br><span class="line">                    res.then(resolve)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    resolve(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这是测试案例</span><br><span class="line">new MyPromise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return new MyPromise((resolve) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res =&gt;&#123;console.log(res)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防抖</span></span><br><span class="line"><span class="keyword">function</span> debounce(fn, <span class="built_in">date</span>) &#123;</span><br><span class="line">    <span class="built_in">let</span> timer; <span class="comment"># 声明接收定时器的变量</span></span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> (...arg) &#123; <span class="comment"># 获取参数</span></span><br><span class="line">        timer &amp;&amp; clearTimeout(timer); <span class="comment"># 清空定时器</span></span><br><span class="line">        <span class="comment"># 生成新的定时器</span></span><br><span class="line">        timer = setTimeout(() =&gt; &#123;  </span><br><span class="line">            # 因为箭头函数里的this指向上层作用域的this,所以这里可以直接用this，不需要声明其他的变量来接收</span><br><span class="line">            fn.apply(this, arg); </span><br><span class="line">        &#125;, date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 节流</span><br><span class="line">function debounce (fn, date) &#123;</span><br><span class="line">    let timer = +new date(); # 声明初始时间</span><br><span class="line">    return function (...arg) &#123; # 获取参数</span><br><span class="line">        let newTimer = +new Date(); # 获取触发事件的时间</span><br><span class="line">        if (newTimer - timer &gt;= data) &#123; # 时间判断,是否满足条件</span><br><span class="line">            fn.apply(this, arg)  # 调用需要执行的函数,修改this值,并且传入参数</span><br><span class="line">            timer = +new Date() # 重置初始时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写AJAX请求"><a href="#手写AJAX请求" class="headerlink" title="手写AJAX请求"></a>手写AJAX请求</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const SERVER_URL = <span class="string">&#x27;/server&#x27;</span>;</span><br><span class="line"><span class="built_in">let</span> xhr = new XMLHttpRequest();</span><br><span class="line"><span class="comment"># 创建Http请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, SERVER_URL, <span class="literal">true</span>);</span><br><span class="line"><span class="comment"># 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.readyState !== 4) <span class="built_in">return</span>;</span><br><span class="line">    <span class="comment"># 请求成功时</span></span><br><span class="line">    <span class="keyword">if</span> (this.status === 200) &#123;</span><br><span class="line">        handle(this.response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        console.error(this.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment"># 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment"># 发送 Http 请求</span></span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn(obj) &#123;</span><br><span class="line">    <span class="comment"># 判断数据是否是复杂类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj instanceof Object) &#123;</span><br><span class="line">        <span class="comment"># 判断数据是否数组</span></span><br><span class="line">        <span class="keyword">if</span> (Array.isArray(obj)) &#123;</span><br><span class="line">            <span class="comment"># 声明一个空数组来接收拷贝后的数据</span></span><br><span class="line">            <span class="built_in">let</span> result = [];</span><br><span class="line">            obj.forEach(item =&gt; &#123;</span><br><span class="line">                <span class="comment"># 需要递归深层遍历，否则复制的是地址</span></span><br><span class="line">                resluit.puah(fn(item))</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment"># 返回输出这个数组,数组拷贝完成</span></span><br><span class="line">            <span class="built_in">return</span> result</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment"># 如果是对象，就声明一个空对象来接收拷贝后的数据</span></span><br><span class="line">            <span class="built_in">let</span> reslut = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                <span class="comment"># 使用递归深层遍历</span></span><br><span class="line">                reslut[k] = fn(obj[k])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写打乱数组顺序的方法"><a href="#手写打乱数组顺序的方法" class="headerlink" title="手写打乱数组顺序的方法"></a>手写打乱数组顺序的方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1,2,3,4,5,6,7,8,9,10];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    const randomIndex = Math.round(Math.random() * (array.length - 1 - i)) + i;</span><br><span class="line">    [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用Promise实现图片的异步加载"><a href="#用Promise实现图片的异步加载" class="headerlink" title="用Promise实现图片的异步加载"></a>用Promise实现图片的异步加载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> imageAsync = (url) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        let img = new Image();</span><br><span class="line">        img.src = url;</span><br><span class="line">        img.onload = () =&gt; &#123;</span><br><span class="line">            console.log(&#x27;图片请求成功, 此处进行通用操作&#x27;)</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.οnerrοr=(err)=&gt;&#123;</span><br><span class="line">            console.log(`失败，此处进行失败的通用操作`);</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、算法基础"><a href="#二、算法基础" class="headerlink" title="二、算法基础"></a>二、算法基础</h2><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h3><p>每遍历一个元素，都会把之前的所有相邻的元素都两两比较一遍，即便是已经排序好的元素<br>思路：每轮循环将最大值排到末尾<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [4, 1, 6, 8, 3, 2, 9, 7];</span><br><span class="line"><span class="keyword">function</span> bubbleSort (arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> j = 0; j &lt; arr.length - 1; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h3><p>思路：选择排序，内层循环，每一圈选出最大的，然后放在后面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [4, 1, 6, 8, 3, 2, 9, 7];</span><br><span class="line"><span class="keyword">function</span> bubbleSort(arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        <span class="built_in">let</span> maxIndex = 0; <span class="comment"># 每一圈选出一个最大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">let</span> j = 0; j &lt; arr.length  - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[maxIndex] &lt; arr[j]) &#123;</span><br><span class="line">                maxIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">let</span> temp = arr[maxIndex];</span><br><span class="line">        arr[maxIndex] = arr[arr.length - i -1]</span><br><span class="line">        arr[arr.length - i -1] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure></p><h3 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [4, 1, 6, 8, 3, 2, 9, 7];</span><br><span class="line"><span class="keyword">function</span> bubbleSort(arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr === null || arr.length === 0) <span class="built_in">return</span> []</span><br><span class="line">    <span class="built_in">let</span> leader = arr[0];</span><br><span class="line">    <span class="built_in">let</span> right = []</span><br><span class="line">    <span class="built_in">let</span> left = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">let</span> i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; leader) &#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> [...bubbleSort(left), leader, ...bubbleSort(right)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(bubbleSort(arr));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、手写代码&quot;&gt;&lt;a href=&quot;#一、手写代码&quot; class=&quot;headerlink&quot; title=&quot;一、手写代码&quot;&gt;&lt;/a&gt;一、手写代码&lt;/h2&gt;&lt;h3 id=&quot;手写promise（简易版）&quot;&gt;&lt;a href=&quot;#手写promise（简易版）&quot; class=&quot;</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面试之九小程序</title>
    <link href="http://yoursite.com/2023/04/27/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/9.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%B9%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2023/04/27/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/9.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%B9%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F/</id>
    <published>2023-04-27T01:48:00.000Z</published>
    <updated>2024-10-14T03:09:54.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信小程序-面试题汇总"><a href="#微信小程序-面试题汇总" class="headerlink" title="微信小程序 面试题汇总"></a>微信小程序 面试题汇总</h2><h3 id="简单描述微信小程序相关文件类型"><a href="#简单描述微信小程序相关文件类型" class="headerlink" title="简单描述微信小程序相关文件类型"></a>简单描述微信小程序相关文件类型</h3><p>微信小程序项目结构主要有四个文件类型</p><blockquote><ul><li>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件</li><li>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式</li><li>js 逻辑处理，网络请求</li><li>json 小程序设置，如页面注册，页面标题及tabBar</li></ul></blockquote><h3 id="小程序的双向绑定和vue哪里不一样"><a href="#小程序的双向绑定和vue哪里不一样" class="headerlink" title="小程序的双向绑定和vue哪里不一样?"></a>小程序的双向绑定和vue哪里不一样?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">    <span class="comment"># 这里设置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="小程序页面间有哪些传递数据的方法"><a href="#小程序页面间有哪些传递数据的方法" class="headerlink" title="小程序页面间有哪些传递数据的方法?"></a>小程序页面间有哪些传递数据的方法?</h3><p><strong>使用全局变量实现数据传递</strong><br>在 app.js 文件中定义全局变量 globalData， 将需要存储的信息存放在里面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">     <span class="comment"># 全局变量</span></span><br><span class="line">  globalData: &#123;</span><br><span class="line">    userInfo: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>使用的时候，直接使用 getApp() 拿到存储的信息<br><strong>使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Navigate</span></span><br><span class="line">wx.navigateTo(&#123;</span><br><span class="line">  url: <span class="string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redirect</span></span><br><span class="line">wx.redirectTo(&#123;</span><br><span class="line">  url: <span class="string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pageB.js</span></span><br><span class="line">...</span><br><span class="line">Page(&#123;</span><br><span class="line">  onLoad: <span class="keyword">function</span>(option)&#123;</span><br><span class="line">    console.log(option.name + <span class="string">&#x27;is&#x27;</span> + option.gender)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      option: option</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="小程序的生命周期函数"><a href="#小程序的生命周期函数" class="headerlink" title="小程序的生命周期函数"></a>小程序的生命周期函数</h3><blockquote><ul><li>onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数</li><li>onShow() 页面显示/切入前台时触发</li><li>onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互</li><li>onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等</li><li>onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时</li></ul></blockquote><h3 id="如何实现下拉刷新"><a href="#如何实现下拉刷新" class="headerlink" title="如何实现下拉刷新"></a>如何实现下拉刷新</h3><p>首先在全局 config 中的 window 配置 enablePullDownRefresh<br>在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法<br>请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新</p><h3 id="bindtabp-和-catchtap的区别是什么"><a href="#bindtabp-和-catchtap的区别是什么" class="headerlink" title="bindtabp 和 catchtap的区别是什么"></a>bindtabp 和 catchtap的区别是什么</h3><p><strong>相同点：</strong>首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分<br><strong>不同点：</strong>他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的</p><h3 id="简述下-wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别"><a href="#简述下-wx-navigateTo-wx-redirectTo-wx-switchTab-wx-navigateBack-wx-reLaunch-的区别" class="headerlink" title="简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?"></a>简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?</h3><p>wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面<br>wx.redirectTo()：关闭当前页面，跳转到新的页面（类似重定向）。但是不允许跳转到 tabbar 页面<br>wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面<br>wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层<br>wx.reLaunch()：关闭所有页面，打开到应用内的某个页面</p><h3 id="登录流程？"><a href="#登录流程？" class="headerlink" title="登录流程？"></a>登录流程？</h3><p>登录流程是调wx.login获取code传给后台服务器获取微信用户唯一标识openid及本次登录的会话密钥（session_key）等）。拿到开发者服务器传回来的会话密钥（session_key）之后，前端要保存wx.setStorageSync(‘sessionKey’, ‘value’)<br>持久登录状态：session信息存放在cookie中以请求头的方式带回给服务端，放到request.js里的wx.request的header里</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微信小程序-面试题汇总&quot;&gt;&lt;a href=&quot;#微信小程序-面试题汇总&quot; class=&quot;headerlink&quot; title=&quot;微信小程序 面试题汇总&quot;&gt;&lt;/a&gt;微信小程序 面试题汇总&lt;/h2&gt;&lt;h3 id=&quot;简单描述微信小程序相关文件类型&quot;&gt;&lt;a href=&quot;#简单</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之八简历网络和浏览器</title>
    <link href="http://yoursite.com/2023/04/22/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/8.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E5%85%AB%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://yoursite.com/2023/04/22/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/8.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E5%85%AB%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2023-04-22T01:48:00.000Z</published>
    <updated>2024-10-14T03:09:54.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从用户在浏览器输入地址到页面渲染完成期间-都发生了什么"><a href="#从用户在浏览器输入地址到页面渲染完成期间-都发生了什么" class="headerlink" title="从用户在浏览器输入地址到页面渲染完成期间 都发生了什么"></a>从用户在浏览器输入地址到页面渲染完成期间 都发生了什么</h3><ul><li>查看是否有有效的service worker缓存</li><li>判断是否有强缓存，也就是未过期的资源，靠expire和cache-control判断</li><li>DNS域名解析</li><li>进行三次握手 + TLS握手<blockquote><ul><li>TLS握手</li><li>客户端请求服务器的证书</li><li>第一次非对称加密，用CA的公钥去解证书签名，如果解出来的hash和证书的信息hash一致则合法</li><li>第二次非对称加密，客户端使用服务器公钥加密随机数</li><li>服务端使用服务端私密解密随机数</li><li>使用随机数进行对此加密</li></ul></blockquote></li><li>向资源发送请求</li><li>协商缓存，使用if-modified-since和etag与服务器对比，或没有改变取本地缓存，返回的状态码是304</li><li>取回资源</li><li>解析网页资源，下载网页中资源<blockquote><p>html,css,font这三类型的资源优先级最高</p></blockquote></li><li>生成dom树和css树，构造render树</li><li>重拍重绘合成</li><li>当DOM的变化引发元素几何属性变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘“</li><li>首次渲染时一定会执行重排，后续如果不改变元素的外形位置尺寸则可以只执行重绘，不执行重排</li><li>重绘得到的像素使用GPU绘制在页面上，一些特殊的element会单独为一个合成层，合理使用合成层可以提高动画效果</li><li>触发DOMContentLoaded事件</li><li>加载图片等外部文件</li><li>触发load事件</li><li>瞎子啊preload资源</li></ul><h3 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h3><ul><li>减少HTTP请求：合并文件、CSS精灵、inline Image</li><li>优化图片：根据实际颜色需要选择色深、压缩</li></ul><h3 id="POST-GET-区别"><a href="#POST-GET-区别" class="headerlink" title="POST GET 区别"></a>POST GET 区别</h3><ul><li>GET回退是无害，POST会再次提交请求</li><li>GET产生的URL地址可以被收藏，POST不行</li><li>GET请求会被浏览器主动缓存，POST不能除非主动设置</li><li>GET只能进行URL编码，而POST可以支持多种编码方式</li><li>GET请求参数会被完整的保留在浏览器历史记录中，而POST的参数不会被保留</li><li>GET请求在URL中传参是有长度限制的，POST没有</li><li>GET比POST更不安全</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li>1xx指示信息-表示请求已经接受，继续处理</li><li>2xx成功</li><li>3xx重定向</li><li>4xx客户端错误</li><li>5xx服务器错误</li></ul><h3 id="WebSocket理解"><a href="#WebSocket理解" class="headerlink" title="WebSocket理解"></a>WebSocket理解</h3><p>WebSocket 是一种网络传输协议，位于OSI模型的应用层，可在单个TCP连接上进行全双工共通信更好的节省服务器资源和宽带达到实时通讯<br>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性连接，并进行数据传输</p><blockquote><p><strong>应用场景</strong></p><ul><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li></ul></blockquote><h3 id="http协议主要特点"><a href="#http协议主要特点" class="headerlink" title="http协议主要特点"></a>http协议主要特点</h3><ul><li>简单快速 - url</li><li>灵活：根据请求头设置不同数据类型</li><li>无连接：不需要连接，结束自动截掉</li><li>无状态：第二次访问也不会有状态，犹如初恋</li></ul><h3 id="http报文组成"><a href="#http报文组成" class="headerlink" title="http报文组成"></a>http报文组成</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li>状态行</li><li>响应头</li><li>空行</li><li>相应体</li></ul><h3 id="如何创建Ajax"><a href="#如何创建Ajax" class="headerlink" title="如何创建Ajax"></a>如何创建Ajax</h3><h4 id="定外卖的思想"><a href="#定外卖的思想" class="headerlink" title="定外卖的思想"></a>定外卖的思想</h4><ul><li>手机、电脑—————–&gt;浏览器</li><li>美团外卖、饿了么等——–&gt;ajax对象</li><li>打开APP 商家、商品——–&gt;ajax.open(method,url,true)</li><li>下单（……）—————&gt;ajax.send()</li><li>监听外卖信息————–&gt;onreadystatechage 4</li><li>开门、验货、处理———-&gt;status == 200 403 503</li></ul><h4 id="封装一下"><a href="#封装一下" class="headerlink" title="封装一下"></a>封装一下</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> ajaxFunc(method, url, data,callback, flag)&#123;</span><br><span class="line">  var xhr = null;</span><br><span class="line">  <span class="comment">#创建ajax对象</span></span><br><span class="line">  <span class="keyword">if</span>(window.XMLHttpRequest)&#123;s</span><br><span class="line">    xhr = new XMLHttpRequest();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;# ie兼容</span><br><span class="line">    xhr = new ActiveXObject(<span class="string">&#x27;Microsoft.XMLHttp&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">#兼容小写，统一转换成大写‘GET’、‘POST’</span></span><br><span class="line">  method = method.toUpperCase();</span><br><span class="line">  <span class="keyword">if</span>(method == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">    xhr.open(method, url + <span class="string">&#x27;?&#x27;</span> + data, flag);</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">    xhr.open(method, url, flag);</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == 4)&#123;</span><br><span class="line">      <span class="keyword">if</span>(xhr.status == 200 || xhr.status == 304)&#123;</span><br><span class="line">        callback(xhr.reponseText);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        console.log(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ajax请求如何取消"><a href="#ajax请求如何取消" class="headerlink" title="ajax请求如何取消"></a>ajax请求如何取消</h3><h4 id="9-1-原生xhr取消请求"><a href="#9-1-原生xhr取消请求" class="headerlink" title="9.1 原生xhr取消请求"></a>9.1 原生xhr取消请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure><h4 id="9-2-axios取消请求"><a href="#9-2-axios取消请求" class="headerlink" title="9.2 axios取消请求"></a>9.2 axios取消请求</h4><p><strong>1.使用CancelToken.source工厂方法创建cancel token</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const CancelToken = axios.CancelToken;</span><br><span class="line">const <span class="built_in">source</span> = CancleToken.<span class="built_in">source</span>();</span><br><span class="line">axios.get(<span class="string">&#x27;/user/123&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line">source.cancel(<span class="string">&#x27;canceled by the user&#x27;</span>)</span><br></pre></td></tr></table></figure><br><strong>2.传递一个executor函数CancelToken的构建函数来创建cancel token</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const CancelToken = axios.CancelToken;</span><br><span class="line"><span class="built_in">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: new CancelToken(<span class="keyword">function</span> executor(c) &#123;</span><br><span class="line">    <span class="comment"># executor 函数接收一个cancel函数作为参数</span></span><br><span class="line">    cancel = c</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment"># 取消</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></p><h3 id="cookie、localStorage、SessionStorage区别"><a href="#cookie、localStorage、SessionStorage区别" class="headerlink" title="cookie、localStorage、SessionStorage区别"></a>cookie、localStorage、SessionStorage区别</h3><p><strong>1.cookie:</strong> 服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，每次发起同源请求时，发送给服务器端。cookie最多能存储4k数据<br><strong>2.sessionStorage:</strong> html5提供的一种浏览器的本地存储的方法，当前窗口关闭后就失效了，并且只能同窗口的同源页面共享访问<br><strong>3.localStorage:</strong> html5提供的一种浏览器本地存储，永久性存储，除非手动删除</p><h3 id="什么是同源策略，什么是跨域"><a href="#什么是同源策略，什么是跨域" class="headerlink" title="什么是同源策略，什么是跨域"></a>什么是同源策略，什么是跨域</h3><h4 id="同源策略：协议、域名、端口三者必须一致"><a href="#同源策略：协议、域名、端口三者必须一致" class="headerlink" title="同源策略：协议、域名、端口三者必须一致"></a>同源策略：协议、域名、端口三者必须一致</h4><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript 施加的安全限制，防止他人恶意攻击网站</p><h3 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h3><h4 id="11-1-CORS"><a href="#11-1-CORS" class="headerlink" title="11.1 CORS"></a>11.1 CORS</h4><p>CORS的关键就是服务器，只要服务器实现了CORS请求</p><h4 id="11-2-JSONP"><a href="#11-2-JSONP" class="headerlink" title="11.2 JSONP"></a>11.2 JSONP</h4><p>jsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求</p><h4 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h4><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;从用户在浏览器输入地址到页面渲染完成期间-都发生了什么&quot;&gt;&lt;a href=&quot;#从用户在浏览器输入地址到页面渲染完成期间-都发生了什么&quot; class=&quot;headerlink&quot; title=&quot;从用户在浏览器输入地址到页面渲染完成期间 都发生了什么&quot;&gt;&lt;/a&gt;从用户在浏</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之七Webpack</title>
    <link href="http://yoursite.com/2023/04/18/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/7.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%B8%83Webpack/"/>
    <id>http://yoursite.com/2023/04/18/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/7.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E4%B8%83Webpack/</id>
    <published>2023-04-18T01:48:00.000Z</published>
    <updated>2024-10-14T03:09:54.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack-面试题汇总"><a href="#webpack-面试题汇总" class="headerlink" title="webpack 面试题汇总"></a>webpack 面试题汇总</h2><h3 id="你知道webpack的作用是什么吗？"><a href="#你知道webpack的作用是什么吗？" class="headerlink" title="你知道webpack的作用是什么吗？"></a>你知道webpack的作用是什么吗？</h3><ul><li>(1) <strong>模块打包。</strong> 可以将不同模块的文件打包整合在一起，并且保证他们之间的引用正确，执行有序，利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性</li><li>(2) <strong>编译兼容。</strong> 通过“webpack”的loader机制，不不仅仅可以帮助我们对代码做“polyfill”，还可以进行斌阿姨转换如“.less”，“.vue”,”.jsx”这类在浏览器无法识别的格式文件，让我们在开发时候可以使用新特性和新语法开发，提高开发效率</li><li>(3) <strong>能力扩展。</strong> 通过webpack的plugin（插件）机制，在我们实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量</li></ul><h3 id="模块打包运行原理"><a href="#模块打包运行原理" class="headerlink" title="模块打包运行原理"></a>模块打包运行原理</h3><p>webpack的整个打包流程：</p><ul><li>（1）读取webpack的配置参数</li><li>（2）启动webpack，创建compiler对象并镜像解析项目</li><li>（3）从入口文件（entry）开始解析，并找到其他导入的依赖关系树；</li><li>（4）对不同文件类型的依赖模块文件使用对应的loader进行编译，最终转成JavaScript；</li><li>（5）整个过程中webpack会通过发布订阅模式，向外抛出一些hooks，而webpack的插件即可通过监听这些关键的事件节点，执行插件任务进而达到敢于输出结果的目的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webpack-面试题汇总&quot;&gt;&lt;a href=&quot;#webpack-面试题汇总&quot; class=&quot;headerlink&quot; title=&quot;webpack 面试题汇总&quot;&gt;&lt;/a&gt;webpack 面试题汇总&lt;/h2&gt;&lt;h3 id=&quot;你知道webpack的作用是什么吗？&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之六TS</title>
    <link href="http://yoursite.com/2023/04/15/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/6.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%85%ADTS/"/>
    <id>http://yoursite.com/2023/04/15/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/6.%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%85%ADTS/</id>
    <published>2023-04-15T01:48:00.000Z</published>
    <updated>2024-10-14T03:08:38.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typeScript面试题相关"><a href="#typeScript面试题相关" class="headerlink" title="typeScript面试题相关"></a>typeScript面试题相关</h2><h3 id="为什么要使用typeScript"><a href="#为什么要使用typeScript" class="headerlink" title="为什么要使用typeScript"></a>为什么要使用typeScript</h3><blockquote><p>增加静态类型，可以在开发编写脚本监测错误，使得代码质量更好，更健壮</p><ul><li>杜绝手误导致的变量名错误</li><li>类型可以一定程度上充当文档</li></ul></blockquote><h3 id="typescript中const和readonly的区别？枚举和常量枚举的区别？接口和类型别名的区别？"><a href="#typescript中const和readonly的区别？枚举和常量枚举的区别？接口和类型别名的区别？" class="headerlink" title="typescript中const和readonly的区别？枚举和常量枚举的区别？接口和类型别名的区别？"></a>typescript中const和readonly的区别？枚举和常量枚举的区别？接口和类型别名的区别？</h3><blockquote><ul><li><strong>const</strong> 和 <strong>readonly</strong>：const可以防止变量值被修改，redonly可以防止变量的属性被修改</li><li><strong>接口</strong>和<strong>类型</strong>：两者都是可以用来描述对象和函数的。与接口不用，类型别名可以用去其他类型，比如基本类型（原始值）、联合类型、元祖</li><li><strong>枚举</strong> 和 <strong>常量枚举</strong>: 常量枚举只能使用常量枚举表达式，并且不用常规的枚举，他们在枚举斌编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。之所以可以这么做</li></ul></blockquote><h3 id="TypeSCript中interface可以Function-Array-Class-Indexable-做声明嘛"><a href="#TypeSCript中interface可以Function-Array-Class-Indexable-做声明嘛" class="headerlink" title="TypeSCript中interface可以Function / Array / Class(Indexable) 做声明嘛"></a>TypeSCript中interface可以Function / Array / Class(Indexable) 做声明嘛</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**可以**/</span><br><span class="line"><span class="comment">## 函数声明</span></span><br><span class="line">interface Say &#123;</span><br><span class="line">    (name: string): viod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> say: Say = (name: string):viod = &gt; &#123;&#125;</span><br><span class="line"><span class="comment">## Array 声明</span></span><br><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br><span class="line"><span class="comment">## class 声明</span></span><br><span class="line">interface PersonalIntl &#123;</span><br><span class="line">    name: string</span><br><span class="line">    sayHi: (name: string): string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TypeScript-如何设计Class的声明"><a href="#TypeScript-如何设计Class的声明" class="headerlink" title="TypeScript 如何设计Class的声明"></a>TypeScript 如何设计Class的声明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在声明类的时候，一般类中都会包含，构造函数、对构造函数中的属性进行类型声明、类中的方法</span></span><br><span class="line">class Greeter &#123;</span><br><span class="line">    greeting: string;</span><br><span class="line">    constructor (message: string) &#123;</span><br><span class="line">        this.greeting = message;</span><br><span class="line">    &#125;</span><br><span class="line">    greet(): stirng &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">&quot;Hello, &quot;</span> + this.greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TypeScript中type和interface区别"><a href="#TypeScript中type和interface区别" class="headerlink" title="TypeScript中type和interface区别"></a>TypeScript中<strong>type</strong>和<strong>interface</strong>区别</h3><p><strong>相同点：</strong></p><ul><li>1.都可以描述对象和函数</li><li>2.都允许扩展（extends）</li></ul><p><strong>不同点：</strong></p><ul><li>1.type可以声明基本类型，联合类型，元祖</li><li>2.type可以使用typeof获取实例的类型进行赋值</li><li>3.多个相同的interface声明可以自动合并</li></ul><p>使用interface描述“数据结构”，使用type描述“类型关系”</p><h3 id="对TypeScript类中成员的public、private、protected、readonly修饰符的理解"><a href="#对TypeScript类中成员的public、private、protected、readonly修饰符的理解" class="headerlink" title="对TypeScript类中成员的public、private、protected、readonly修饰符的理解"></a>对TypeScript类中成员的public、private、protected、readonly修饰符的理解</h3><blockquote><p><strong>public</strong>:成员都默认为publi，被次选定修饰符的成员可以被外部访问<br><strong>private</strong>:被此限定符修饰的成员是只可以被类的内部访问（子类不可以访问）<br><strong>protected</strong>:被限定符修饰的成员是只可以被类的内部以及子类访问<br><strong>readonly</strong>:关键字将属性设置为只读的。只读属性必须在声明时或构建函数里被初始化</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;typeScript面试题相关&quot;&gt;&lt;a href=&quot;#typeScript面试题相关&quot; class=&quot;headerlink&quot; title=&quot;typeScript面试题相关&quot;&gt;&lt;/a&gt;typeScript面试题相关&lt;/h2&gt;&lt;h3 id=&quot;为什么要使用typeScr</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之五Vue3</title>
    <link href="http://yoursite.com/2023/04/13/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/5.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%BA%94Vue3/"/>
    <id>http://yoursite.com/2023/04/13/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/5.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%BA%94Vue3/</id>
    <published>2023-04-13T01:48:00.000Z</published>
    <updated>2024-10-14T06:27:30.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue3响应式相较于vue2具体哪些变化"><a href="#vue3响应式相较于vue2具体哪些变化" class="headerlink" title="vue3响应式相较于vue2具体哪些变化"></a>vue3响应式相较于vue2具体哪些变化</h2><p>1.数据拦截Object.defineProperty改变了Proxy + Object.defineProperty的拦截方式，其中</p><ul><li>ref:使用Object.defineProperty + Proxy 方式</li><li>reactive: 使用Proxy</li></ul><p>2.创建响应式数据的在语法层面有了改变：</p><ul><li>Vue2：通过Data来创建响应式数据</li><li>Vue3：通过ref，reactive等方式来创建响应式数据</li></ul><p>3.依赖收集上面的改变</p><ul><li>Vue2：Watcher + Dep</li><li>Vue3: weackMap + Map + Set</li><li>这种实现方式可以实现更加细粒度的依赖追踪和更新控制 </li></ul><h2 id="nextTikck实现原理"><a href="#nextTikck实现原理" class="headerlink" title="nextTikck实现原理"></a>nextTikck实现原理</h2><h3 id="前瞻栗子"><a href="#前瞻栗子" class="headerlink" title="前瞻栗子"></a>前瞻栗子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div <span class="built_in">id</span>=<span class="string">&quot;counterRef&quot;</span>&gt;计数：&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button @click=<span class="string">&quot;increment&quot;</span>&gt;增加技术&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">const count = ref(0)</span><br><span class="line">const increment = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i = 1; i &lt;= 1000; i++) &#123;</span><br><span class="line">        count.value = i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>思考🤔：点击按钮后，页面会渲染几次?<br>答案：只会渲染一次，同步代码中多次相应式数据做了修改，多次修改被毁<strong>合并</strong>为一次，之后根据最终的修改结果<strong>异步</strong>的去更新DOM。</p><p>思考🤔：倘若不合并，并且同步的去修改DOM，会有什么问题？<br>答案：数据一变就同步更新DOM，会导致频繁的重排重绘，非常损耗性能</p><p>思考🤔：异步更新会带来的问题？<br>答案：无法及时获取到更新后的DOM值<br>原因：因为获取的DOM数据是同步代码，DOM的更新是异步代码，同步代码会现优先于异步代码<br>解决方案：将获取的DOM数据的同步任务包装成一个微任务，浏览器在完成一次渲染后，就会立即执行微任务<br><strong>当前我们自己的解决方案</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const increment = () =&gt; &#123;</span><br><span class="line">    <span class="comment"># 比如当前最新数据是 2</span></span><br><span class="line">    count.vlaue++</span><br><span class="line">    console.log(<span class="string">&#x27;同步通过Dom拿textContent数据：&#x27;</span>， coutnerRef.value.textContent) // 1</span><br><span class="line">    Promise.resolve().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;最新的数据：&#x27;, count.value) // <span class="number">2</span></span><br><span class="line">        console.log(&#x27;异步通过Dom拿textContent数据：&#x27;， coutnerRef.value.textContent) // <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>nextTick帮我们做了就是上面的事情，将一个任务包装成一个微任务</strong><br>nextTick 返回的是一个Promise<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const increment = () =&gt; &#123;</span><br><span class="line">    <span class="comment"># 比如当前最新数据是 2</span></span><br><span class="line">    count.vlaue++</span><br><span class="line">    console.log(<span class="string">&#x27;同步通过Dom拿textContent数据：&#x27;</span>， coutnerRef.value.textContent) // 1</span><br><span class="line">    nextTick(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;最新的数据：&#x27;, count.value) // <span class="number">2</span></span><br><span class="line">        console.log(&#x27;异步通过Dom拿textContent数据：&#x27;， coutnerRef.value.textContent) // <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    # 或者下面写法</span><br><span class="line">    await nextTick()</span><br><span class="line">    console.log(&#x27;最新的数据：&#x27;, count.value) // <span class="number">2</span></span><br><span class="line">    console.log(&#x27;异步通过Dom拿textContent数据：&#x27;， coutnerRef.value.textContent) // <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue3响应式相较于vue2具体哪些变化&quot;&gt;&lt;a href=&quot;#vue3响应式相较于vue2具体哪些变化&quot; class=&quot;headerlink&quot; title=&quot;vue3响应式相较于vue2具体哪些变化&quot;&gt;&lt;/a&gt;vue3响应式相较于vue2具体哪些变化&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之五Vue2</title>
    <link href="http://yoursite.com/2023/04/11/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/5.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%BA%94Vue2/"/>
    <id>http://yoursite.com/2023/04/11/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/5.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%BA%94Vue2/</id>
    <published>2023-04-11T01:48:00.000Z</published>
    <updated>2024-10-15T10:51:54.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVC和MVVM区别"><a href="#MVC和MVVM区别" class="headerlink" title="MVC和MVVM区别"></a>MVC和MVVM区别</h2><p>MVC 全名 Model View Controller，是模型（model）- 视图（view）-控制器（controller）的缩写，一种软件设计典范</p><ul><li>（1）Model 模型：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li><li>（2）View 视图：是应用程序中处理数据显示部分。通常视图是依据模型数据创建的</li><li>（3）Controller 控制器：是应用程序中处理用户交互的部分。通常控制器负责从事图读取数据，控制用户输入。冰箱模型发送数据</li></ul><p>MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话就是在Controller里面吧Model的数据赋值给View。</p><blockquote><p><strong>MVVM</strong><br>MVVM新增VM类<br>ViewModel层：做了两件事达到了数据的双向绑定，一是将【模型】转成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二将【视图】转化成【模型】，即将所看到多页面转化成后端数据，实现DOM事件监听<br>MVVM和MVC最大的区别就是，它实现了View和Model的自动同步，也就是当Model的属性改变是，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后改属性对应View层显示自动改变（对应Vue数据驱动的思想）<br>整体来来，MVVM比MVC精简了很多，因为MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性<br>严格来说MVVM要求View不能和Model直接通行，而Vue提供了$ref这个属性，让Model可以直接操作View，违反了这一规定，所以Vue没有完全遵循MVVM。</p></blockquote><h2 id="Vue是如何实现响应式数据"><a href="#Vue是如何实现响应式数据" class="headerlink" title="Vue是如何实现响应式数据"></a>Vue是如何实现响应式数据</h2><blockquote><p><strong>Vue2:</strong><br>Object.definPropert重写定义data中所有属性，添加了访问器属性，当读取data中数据是自动调用get方法，当修改data中数据时，自动调用set方法，监测到数据的变化。<br>数组变化方法pop，push，shift，unshift，splice、sort，reverse这七种，只要这些方法执行改了数组内容</p></blockquote><blockquote><p><strong>Vue3：</strong><br>改用了proxy，可以直接监听数组变化</p></blockquote><h2 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a>Vue的优点</h2><p><strong>轻量级框架：</strong> 只关注视图层。是一个构建数据的视图集合，大小只在几十kb<br><strong>简单易学：</strong> 国人开发，中文文档，不存在语言障碍，易于学习和理解<br><strong>双向数据绑定：</strong> 保存了angular的特点，在数据操作方便更加简单；<br><strong>组件化：</strong> 保存了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势。<br><strong>视图，数据，结构分离：</strong> 使数据的更改变成简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><h2 id="为什么vue组件中data必须是一个函数"><a href="#为什么vue组件中data必须是一个函数" class="headerlink" title="为什么vue组件中data必须是一个函数"></a>为什么vue组件中data必须是一个函数</h2><p>对象为引用类型，当复用组件，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件的data会被修改，而使用返回对象的函数，由于每次返回都是一个新对象（Object的实例），引用地址不同，不会出现这个问题</p><h2 id="父子组件生命周期调用顺序"><a href="#父子组件生命周期调用顺序" class="headerlink" title="父子组件生命周期调用顺序"></a>父子组件生命周期调用顺序</h2><p>渲染循序：先父后子，完成循序：先子后父<br>更新循序：父更新导致子更新，子更新完成后父<br>销毁循序，先父后子，完成顺序：先子后父<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><blockquote><p>时间复杂度：个树的完全diff算法是一个事件复杂度为o（n * 3），vue进行优化转化成o（n）<br>Diff算法，当data发生改变，会根据新的数据生成一个新的虚拟dom，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法，会找到不同地方，只会渲染不同地方，总的太说就是减少dom，重绘和回流<br><strong>理解：</strong><br>（1）最小量更新，key很重要。这个可以是这个节点唯一标识，告诉diff算法，在更改前后他们是同一个节点</p><ul><li>扩展v-for为什么要有key，没有key会暴力复用，举个例子的话说一个比如移动字节或者增加节点（修改DOM），加key只会移动减少操作DOM。</li></ul></blockquote><blockquote><p>（2）只有同一个虚拟节点才会进行精细化比较，否则就是暴力删除旧的。插入新的<br>（3）只进行同层比较，不会进行跨层比较</p></blockquote><h2 id="v-for-为什么要加key"><a href="#v-for-为什么要加key" class="headerlink" title="v-for 为什么要加key"></a>v-for 为什么要加key</h2><blockquote><p>如果不使用key，vue会使用一个最大限制减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。Key是为了Vue中vnode的唯一标记，通过key，diff操作可以更准确，更快速</p><ul><li><strong>更准确：</strong>因为带key就不是就地复用了，在someNode函数a.key === b.key对比中可以避免就地复用的情况，所以更加准确</li><li><strong>更快速：</strong>利用key的唯一性生成map对象来获取对应节点，比遍历方式更快</li></ul></blockquote><h2 id="Vue-的路由实现"><a href="#Vue-的路由实现" class="headerlink" title="Vue 的路由实现"></a>Vue 的路由实现</h2><ul><li>（1）解释hash模式和history模式的实现原理</li><li>（2）说一下$route与$router的区别</li><li>（3）vueRouter有几种导航守卫</li><li>（4）解释下vueRouter的完整的导航解析流程是什么</li></ul><h4 id="1-解释hash模式和history模式的实现原理"><a href="#1-解释hash模式和history模式的实现原理" class="headerlink" title="(1) 解释hash模式和history模式的实现原理"></a>(1) 解释hash模式和history模式的实现原理</h4><blockquote><p>hash值变化，不会导致浏览器向服务器发起请求，浏览器不发请求，就不会刷新页面；通过hashchange事件，可以知道hash发生了那些变化，让后根据hash变化来实现更新页面部分内容的操作。<br>history模式的实现，主要是html5标注两个api，pushState和replaceState，这两个api可以在改变Url，但是不会发送请求，这样就可以监听url变化来实现更新页面部分内容的操作<br><strong>两种模式的区别：</strong></p><ul><li>首先Url的展示上，hash模式有#</li><li>刷新页面时，hash模式可以正常加载到hash值对应的页面，而history没有做处理的话，会返回404，一般需要后端将页面配置重定向到首页路由</li><li>在兼容方面hash可以支持低版本浏览和el</li></ul></blockquote><h4 id="2-router-与-route-的区别"><a href="#2-router-与-route-的区别" class="headerlink" title="(2)$router 与 $route 的区别"></a>(2)$router 与 $route 的区别</h4><blockquote><p><strong>$route对象表示当前路由信息，包含当前URL解析得到的信息，包含当前的路径，参数，query对象</strong></p><ul><li>$route.path: 字符串，当前路由路径</li><li>$route.params 动态片段和全匹配片段</li><li>$router.query url查询参数</li><li>$rouer.name 路径命</li></ul></blockquote><blockquote><p><strong>$router对象是全局路由的实例，是router构造方法的实例</strong><br><strong>$router对象常用的方法：</strong><br>push: 向history技术栈添加新的记录<br>go: 页面路由跳转前进或后退<br>replace: 替换当前的页面，不会向history栈添加一个新的记录</p></blockquote><h4 id="（3）vueRouter有哪些导航守卫"><a href="#（3）vueRouter有哪些导航守卫" class="headerlink" title="（3）vueRouter有哪些导航守卫"></a>（3）vueRouter有哪些导航守卫</h4><ul><li>全局前置/钩子： beforeEach、afterEcah</li><li>路由独享守卫；beforeEnter</li><li>组件内守卫：beforRouteEnter、beforeRouterUpdata、beforeRouteLeave</li></ul><h4 id="4-vueRouter-的完整导航解析流程是什么"><a href="#4-vueRouter-的完整导航解析流程是什么" class="headerlink" title="(4) vueRouter 的完整导航解析流程是什么"></a>(4) vueRouter 的完整导航解析流程是什么</h4><ul><li>导航被触发</li><li>在失活的组件里调用离开守卫</li><li>调用全局的beforeEach守卫</li><li>在重用的组件里调用beforeRouterUpdate守卫</li><li>在路由配置里调用beforEnter</li><li>解析异步路由组件</li><li>在被激活的组件里调用beforeRouteEnter</li><li>调用全局的beforeResolve守卫</li><li>导航被确认</li><li>调用全局的afterEach钩子</li><li>触发DOM更新</li><li>用创建好的实例调用beforRouteEnter守卫的next的回调函数</li></ul><h2 id="vuex的个人理解"><a href="#vuex的个人理解" class="headerlink" title="vuex的个人理解"></a>vuex的个人理解</h2><p>Vuex是专门为vue提供的全局状态管理系统，用户多组件数据共享，数据等<br>主要包括以下几个模块</p><ul><li>state：定义了应用状态的数据结构，可以这里设置默认的初始化状态</li><li>geeter：允许组件从store中获取数据，mapGetter辅助函数仅仅将store中的geeter映射到全局计算属性</li><li>mutation：唯一更改story中状态的方法，必须是同步函数</li><li>action：用户提交mutations。而不是直接更改状态，可以包含异步</li><li>module：允许将单一的store拆分多个store且同时保存单一状态树中</li></ul><h2 id="keep-alive使用场景和原理"><a href="#keep-alive使用场景和原理" class="headerlink" title="keep-alive使用场景和原理"></a>keep-alive使用场景和原理</h2><blockquote><p>Keep-alive是Vue内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p><ul><li>（1）常用的两个属性include/exclude，允许组件有条件的进行缓存</li><li>（2）两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态</li></ul></blockquote><h2 id="Vue-extend-作用和原理"><a href="#Vue-extend-作用和原理" class="headerlink" title="Vue.extend 作用和原理"></a>Vue.extend 作用和原理</h2><p>Vue.extend使用基础Vue构造器，创建一个“子类”。参数是一个包含组件选项的对象<br>其实就是一个子类构造器是Vue组件的核心api实现思路就是使用原型继承的方法返回了Vue的子类并且利用mergeOptions把传入组件的options和父类的options进行合并</p><h2 id="vue组件通讯"><a href="#vue组件通讯" class="headerlink" title="vue组件通讯"></a>vue组件通讯</h2><ul><li>（1）props/$emit+v-on：通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息</li><li>（2）ref 与 $parent / $children 适用 父子组件通信</li><li>（3）Vuex：全局数据管理库，可以通过vuex管理全局的数据流</li><li>（4）$atters/$listeners：vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信</li><li>（5）provide/inject：以允许一个祖父组件想其他所有子孙后代诸如一个依赖，不论组件层级有多深，并在起上下游关系成立的时间里始终生效，这成为跨组件通讯的基础</li></ul><h2 id="computed和watch有什么区别"><a href="#computed和watch有什么区别" class="headerlink" title="computed和watch有什么区别"></a>computed和watch有什么区别</h2><p>Computed：<br>（1）computed是计算属性，也就是计算值，它更多用于计算值的场景<br>（2）computed具有缓存性，computed的值在getter执行后是会缓存，只有依赖的属性值改变之后，下一次获取computed的值时才会重写调用对应的getter来计算<br>（3）computed适用于计算比较消耗性能的计算场景</p><p>Watch：<br>（1）更多的是【观察】的作用，类似某些数据的监听回调<br>（2）无缓存性，页面重新渲染时值不变化也会执行</p><h2 id="虚拟DOM的优劣如何"><a href="#虚拟DOM的优劣如何" class="headerlink" title="虚拟DOM的优劣如何"></a>虚拟DOM的优劣如何</h2><p>虚拟DOM，其实就是用对象的方式取代真实的DOM操作，把真实的DOM操作放在内存中，在内存中的对象里做模拟操作，当页面打开浏览器会解析HTML元素，构建一个DOM树，将状态全部保存起来，在内存当中模拟我们真实的DOM操作，操作完后会生成一颗DOM树，两个DOM树进行比较，根据diff算法比较两个DOM树不同的地方。只会渲染一次不同地方<br>（个人理解）虚拟dom他不是正式DOM，是根据模板生成的js对象，根据这个js对象再去生成真实的dom对象</p><p>优点：<br>（1）保证性能下限：虚拟DOM可以经过diff找出最小差异，然后批量进行patch，这种操作虽然比不上手动优化，但是比起粗暴的DOM操作性能要好很多，<br>（2）无需手动操作DOM：蓄力DOM的diff和patch都是在一次性更新中自动进行的，我们无需手动操作DOM，极大提高开发效率<br>（3）跨平台性：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以镜像更方便的跨平台操作，比如服务器渲染、移动端开发<br>缺点：<br>（1）无法进行极致优化：在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致有阿虎，比如VScode采用直接手动操作DOM的方式进行极端的性能优化</p><h2 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理"></a>虚拟DOM实现原理</h2><ul><li>（1）虚拟DOM本质上是JavaScript对象，是对实际DOM的抽象</li><li>（2）状态变更时，记录新树和旧树的差异</li><li>（3）最后把差异更新到真正dom中</li></ul><h2 id="nextTick-是什么？"><a href="#nextTick-是什么？" class="headerlink" title="$nextTick 是什么？"></a>$nextTick 是什么？</h2><p>Vue实现响应式并不是在数据发生后立即更新的DOM，使用$nexTick是在下次DOM更新循环结束之后立即执行延迟回调，在修改数据之后使用，则可以在回调中获取更新后的DOM<br>优先于Promise.then方法，是微任务，可以避免多一次队列，进而少一次ui渲染</p><h2 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h2><p>Vue的编译过程就是讲template转化为render函数过程，分为三步<br>第一步：讲模板字符串转化成elment ASTS解析器<br>第二步：是对ast镜像静态节点标记，主要用来做虚拟DOM的渲染优化<br>第三步：使用element AST生成render函数代码字符串</p><h2 id="Vue修饰符有哪些"><a href="#Vue修饰符有哪些" class="headerlink" title="Vue修饰符有哪些"></a>Vue修饰符有哪些</h2><blockquote><p><strong>事件修饰符</strong></p><ul><li>（1）.stop阻止事件继续传播</li><li>（2）.prevent阻止标签默认行为</li><li>（3）.once事件将只会触发一次</li><li>（4）.passive 告诉浏览器你不想阻止事件的默认行为</li></ul></blockquote><blockquote><p><strong>v-model修饰器</strong></p><ul><li>（1）.number自动将用户输入值转化成数值类型</li><li>（2）.trim自动过滤用户输入的收尾空格</li></ul></blockquote><blockquote><p><strong>键盘事件的修饰符</strong></p><ul><li>（1）.enter </li><li>（2）.tab</li><li>（3）.delete（捕获删除和退格键）</li><li>（4）.esc</li><li>（5）up、down、left、right</li></ul></blockquote><h2 id="Vue性能优化"><a href="#Vue性能优化" class="headerlink" title="Vue性能优化"></a>Vue性能优化</h2><blockquote><p><strong>编码优化：</strong></p><ul><li>（1）事件代理</li><li>（2）keep-alive</li><li>（3）拆分组件</li><li>（4）key保证唯一性</li><li>（5）路由懒加载、异步组件</li><li>（6）防抖节流</li></ul></blockquote><blockquote><p><strong>Vue加载性能优化</strong></p><ul><li>（1）第三方模块按需引入 （babel-plugin-component）</li><li>（2）图片懒加载</li></ul></blockquote><h2 id="vue3和vue2区别"><a href="#vue3和vue2区别" class="headerlink" title="vue3和vue2区别"></a>vue3和vue2区别</h2><ul><li>（1）双向数据绑定区别，vue3采用的 proxy</li><li>（2）setup函数</li><li>（3）默认懒加载</li></ul><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><ul><li>（1）beforeCreate（）创建前，这时候data中数据，还未定义，所以不能使用</li><li>（2）create（）创建后，最早开始使用data和methods中数据的钩子函数</li><li>（3）beforeMount（）挂载前，指令时已解析完成内存中dom树，但是尚未挂载到页面中，页面还是旧的</li><li>（4）mounted（）挂载后，dom已经渲染完成，此时页面和内存都是最新的数据，最早可以操作dom元素钩子函数</li><li>（5）beforeUpdate（）更新前，当视图层的数据发生改变会执行这个钩子，内存更新，但是dom节点还未更新，数据没有与页面同步</li><li>（6）updated（）更新后，数据更新完成以后出发的方法，dom节点已经更新</li><li>（7）beforeDestroy（）即将销毁data和methods中数据此时还是可以使用的，可以做一些释放内存的操作</li><li>（8）detroyed（）销毁完毕  组件已经全部销毁，vue实例已经被销毁，vue中任意数据都不可用</li></ul><h2 id="v-for和v-if的优先级"><a href="#v-for和v-if的优先级" class="headerlink" title="v-for和v-if的优先级"></a>v-for和v-if的优先级</h2><p>v-for的优先级比v-if要高。所以vue会先进行遍历，然后再进行条件判断，这样在条件为假的时候会造成不必要的性能浪费。</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><blockquote><p>全局的：vue.directive{“”, {}}<br>局部：directives:{指令名：{钩子函数}}<br>Bind：只调用一次，指令第一次绑定元素时调用，这里可以进行一次性的初始化设置<br>Inserted：被绑定元素插入父节点调用（仅保证父节点存在，但不一定已被插入文档）<br>Update：所在组件VNode更新是调用，但是可能发生在其子VNode更新前。<br><strong>参数：</strong></p><ul><li>El：指令所绑定的元素</li><li>Binding：一个对象包含一下</li><li>Name：指令名，不包括v-前缀</li><li>Value：指令绑定值</li></ul></blockquote><h2 id="什么是mixin"><a href="#什么是mixin" class="headerlink" title="什么是mixin"></a>什么是mixin</h2><p>Mixin是我们能够为vue组件编写插拔和可重用功能，mixin项目变更复杂的时候，多个组件间有重复逻辑可以用到mixin，在执行时优化组件自己的</p><h2 id="单页面应用和多页面应用区别以及有优缺点："><a href="#单页面应用和多页面应用区别以及有优缺点：" class="headerlink" title="单页面应用和多页面应用区别以及有优缺点："></a>单页面应用和多页面应用区别以及有优缺点：</h2><blockquote><p><strong>单页面：只有一个html页面，跳转方式是组件之间切换</strong></p><ul><li>优点：跳转流畅，组件化开发、组件复用、开发便捷</li><li>缺点：首屏加载过慢</li></ul></blockquote><blockquote><p><strong>多页面：有多个页面，跳转方式是页面直接跳转</strong></p><ul><li>优点：首屏加载快</li><li>缺点：跳转速度慢</li></ul></blockquote><h2 id="vue首屏加载优化"><a href="#vue首屏加载优化" class="headerlink" title="vue首屏加载优化"></a>vue首屏加载优化</h2><blockquote><p>（1）对第三方js库进行优化，分离打包，或者放在cdn服务器上<br>（2）使用路由懒加载<br>（3）图片资源压缩，icon资源进行雪碧图、<br>（4）开启gizp压缩 npm i compression-webpack-plugin -D<br>（5）代码层面优化</p><ul><li>合理使用v-if和v-show</li><li>合理使用watch和computed</li><li>使用v-for必须添加key，做好唯一标识id，避免v-for和v-if同时使用</li><li>定时器销毁，</li></ul></blockquote><h2 id="vue的整个实现流程"><a href="#vue的整个实现流程" class="headerlink" title="vue的整个实现流程"></a>vue的整个实现流程</h2><ul><li>第一步：解析模板成render函数</li><li>第二步：响应式开始监听</li><li>第三步：首次渲染，显示页面，且绑定依赖</li><li>第四步：data属性变换，触发render</li></ul><h3 id="第一步：解析模板成render函数"><a href="#第一步：解析模板成render函数" class="headerlink" title="第一步：解析模板成render函数"></a>第一步：解析模板成render函数</h3><ul><li>with的用法</li><li>模板中的所有信息都被render函数包含</li><li>模板中用到的data中的属性，都变成js变量 </li><li>模板中的v-model,v-for,v-on都变成了js逻辑</li><li>render函数返回的vnode</li></ul><h3 id="第二步：响应式开始监听"><a href="#第二步：响应式开始监听" class="headerlink" title="第二步：响应式开始监听"></a>第二步：响应式开始监听</h3><ul><li>Object.defineProperty</li><li>将data的属性代理到vm上</li></ul><h3 id="第三步：首次渲染，显示页面，且绑定依赖"><a href="#第三步：首次渲染，显示页面，且绑定依赖" class="headerlink" title="第三步：首次渲染，显示页面，且绑定依赖"></a>第三步：首次渲染，显示页面，且绑定依赖</h3><ul><li>初次渲染，执行updateComponent，执行vm._render()</li><li>执行render函数，会访问到vm.list和vm.title</li><li>会被响应式的get方法监听到</li><li>执行updateComponent，会走到vdom的patch方法</li><li>patch将vnode渲染DOM，初次渲染完成</li></ul><h3 id="第四步：data属性变化，触发render"><a href="#第四步：data属性变化，触发render" class="headerlink" title="第四步：data属性变化，触发render"></a>第四步：data属性变化，触发render</h3><h2 id="说说你对SPA单页面的理解"><a href="#说说你对SPA单页面的理解" class="headerlink" title="说说你对SPA单页面的理解"></a>说说你对SPA单页面的理解</h2><p>仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。<br><strong>优点：</strong></p><blockquote><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免不需要的跳转和重复渲染</li><li>基于上面一点，SPA相对服务器压力小</li><li>前后端责任分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></blockquote><h2 id="你有对Vue项目进行哪些优化"><a href="#你有对Vue项目进行哪些优化" class="headerlink" title="你有对Vue项目进行哪些优化"></a>你有对Vue项目进行哪些优化</h2><p>参考本文作者的另一篇文章<a href="https://juejin.cn/post/6844903913410314247">《 Vue 项目性能优化 — 实践指南 》</a>，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。<br><strong>(1)代码层面的优化</strong></p><blockquote><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul></blockquote><p><strong>（2）Webpack 层面的优化</strong></p><blockquote><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul></blockquote><p><strong>（3）基础的 Web 技术的优化</strong></p><blockquote><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul></blockquote><h2 id="渲染器最核心功能是什么"><a href="#渲染器最核心功能是什么" class="headerlink" title="渲染器最核心功能是什么"></a>渲染器最核心功能是什么</h2><p>渲染器最核心的功能是处理虚拟DOM到真实DOM的渲染过程，这个过程包含几个阶段<br>1.挂载：初次渲染时，渲染器会将虚拟DOM转化成真实的DOM插入页面，他会根据虚拟节点树递归创建DOM元素并设置相关属性<br>2.更新：当组件的状态或属性变化时，渲染器会计算新旧虚拟DOM的差异，通过Patch过程最小化更新真实DOM<br>3.卸载：当组件被销毁时，渲染器需要将其从DOM中移除，并进行清理工作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MVC和MVVM区别&quot;&gt;&lt;a href=&quot;#MVC和MVVM区别&quot; class=&quot;headerlink&quot; title=&quot;MVC和MVVM区别&quot;&gt;&lt;/a&gt;MVC和MVVM区别&lt;/h2&gt;&lt;p&gt;MVC 全名 Model View Controller，是模型（model</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之四JS</title>
    <link href="http://yoursite.com/2023/04/09/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/4.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E5%9B%9BJS/"/>
    <id>http://yoursite.com/2023/04/09/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/4.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E5%9B%9BJS/</id>
    <published>2023-04-09T01:48:00.000Z</published>
    <updated>2024-10-16T03:36:35.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-面试题汇总"><a href="#JavaScript-面试题汇总" class="headerlink" title="JavaScript 面试题汇总"></a>JavaScript 面试题汇总</h2><h3 id="typeof、instanceof、toString的区别"><a href="#typeof、instanceof、toString的区别" class="headerlink" title="typeof、instanceof、toString的区别"></a>typeof、instanceof、toString的区别</h3><p>三种都是JS中用于获取数据类型的方法</p><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><p>用于笔记基础的数据类型和引用，返回的有<strong>number</strong>、<strong>string</strong>、<strong>boolean</strong>、<strong>null</strong>、<strong>undefined</strong>、<strong>object</strong></p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>用来判断一个对象是否为某个构造函数的实例</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>想要区别对象或者数组、函数是不行的，<strong>null</strong>和<strong>Array</strong>的结构也是object</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(2); // <span class="string">&quot;[object Number]&quot;</span></span><br><span class="line">Object.prototype.toString.call(<span class="string">&#x27;&#x27;</span>); // <span class="string">&quot;[object String]&quot;</span></span><br><span class="line">Object.prototype.toString.call(<span class="literal">true</span>); // <span class="string">&quot;[object Boolean]&quot;</span></span><br><span class="line">Object.prototype.toString.call(undefined); // <span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line">Object.prototype.toString.call(null); // <span class="string">&quot;[object Null]&quot;</span></span><br><span class="line">Object.prototype.toString.call(Math); // <span class="string">&quot;[object Math]&quot;</span></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;); // <span class="string">&quot;[object Object]&quot;</span></span><br><span class="line">Object.prototype.toString.call([]); // <span class="string">&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="什么是作用域链"><a href="#什么是作用域链" class="headerlink" title="什么是作用域链"></a>什么是作用域链</h3><p>作用域链分为两种</p><ul><li>全局作用域：绑定window上，为全部作用域链的最顶层</li><li>函数作用域：函数执行的时候有一个技术栈，并创建执行环境即执行上下文对象，上下文对象中有一个大对象</li><li>块级作用域</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是通过函数嵌套的方式保证函数内外作用域隔离，以函数内部变量等信息只能在内部读取，并且外部的变量不影响内部</p><ul><li>可以创建私有变量，通过在外部调用闭包函数访问函数内部的变量</li><li>使已经运行结束的函数上下文中的变量对象继续留在内存中</li></ul><h4 id="闭包特性"><a href="#闭包特性" class="headerlink" title="闭包特性"></a>闭包特性</h4><ul><li>函数嵌套函数</li><li>函数内部可以引用函数外部的参数和变量（用于链式作用域）</li><li>参数和变量不会被垃圾回收机制回收</li></ul><p><strong>作用域链正是闭包的手段</strong><br><img src="https://raw.githubusercontent.com/riceCk/riceBlog/master/images/closure1.png" alt="闭包"><br><strong>如果自动生成的闭包，会被销毁的，例如</strong><br><img src="https://raw.githubusercontent.com/riceCk/riceBlog/master/images/closure.png" alt="闭包"><br><strong>函数嵌套函数,手动制造闭包，不会被回收</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">eat</span></span> () &#123;</span><br><span class="line">    var food = <span class="string">&#x27;鸡翅&#x27;</span></span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(food)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 可以创建私有变量，通过在外部调用闭包函数访问函数内部的变量</span></span><br><span class="line">var look = eat();</span><br><span class="line">look() <span class="comment"># 鸡翅</span></span><br></pre></td></tr></table></figure><br><strong>闭包应用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i = 0; i &lt;= 3; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (i) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="let、var和const"><a href="#let、var和const" class="headerlink" title="let、var和const"></a>let、var和const</h3><ul><li>var：变量提升，会将变量的生命提前到代码块顶部，赋值还是在原型的位置，若在赋值前使用，就会出现展示性死去undefined</li><li>let：声明只在当前代码块内，var的声明会被提升到全局</li><li>const：不可重复声明</li></ul><h3 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h3><h4 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h4><p>js事件循环的主要部分有一个栈、两个队列、一个幕后线程。<br>开始的时候，执行栈中会执行全部的同步代码，同步代码中如果有异步函数调用如setTimeout、http请求等，会将对应的请求放到幕后线程去处理，当幕后线程处理完异步请求，比如setTimeout的时间到了，或者http请求获得响应，并且当执行栈中全部执行完毕（为空），会触发一次<strong>事件循环</strong>，将执行宏任务队列中第一个任务，任务执行完毕，执行微任务队列中全部任务。微任务队列全部执行完成后，事件循环再次启动，执行下一个宏观任务，如当前任务队列为空，他会一直等待任务的到来，这叫任务循环</p><ul><li>宏任务：setTimeout setInterval用户交互操作UI渲染</li><li>微任务：promise，nextTick,Async/Await</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/27/170847d202084604~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="事件循环"></p><h4 id="解答2"><a href="#解答2" class="headerlink" title="解答2"></a>解答2</h4><p>1.首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行<br>2.在执行同步代码的时候，如果遇到了异步事件，js引擎应不会一直等待其返回结果，而是会将事件挂起，继续执行执行栈中其他任务<br>3.当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。<br>4.任务队列可以分为宏任务队列和微任务队列，当当前执行栈中事件执行完毕后，js引擎首先会判断微任务队列是否有任务可以执行，如果有就将微任务对首的事件栈中执行<br>5.当微任务队列中的任务都执行完成后再将判断宏任务队列中的任务。</p><h3 id="如何判断两个对象相等"><a href="#如何判断两个对象相等" class="headerlink" title="如何判断两个对象相等"></a>如何判断两个对象相等</h3><p>1.递归遍历<br>2.JSON.stringify</p><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><ul><li>算法优化</li><li>CDN</li><li>图片压缩</li><li>使用浏览器缓存</li><li>图片懒加载</li><li>页面滚动加载</li><li>JS、CSS、HTML等文件压缩</li><li>开启web服务器的gzip</li><li>使用nginx方向代理</li><li>减少DOM操作</li></ul><p>JS防抖和节流debounce Throttle<br>Debounce防抖：在事件最后一次触发n毫秒之内执行事件，不管事件曾被触发过多少次。<br>Throttle节流：事件在第一次触发后n毫秒内，不论事件是否继续触发，都执行</p><h3 id="for…of-和-for…in的区别"><a href="#for…of-和-for…in的区别" class="headerlink" title="for…of 和 for…in的区别"></a>for…of 和 for…in的区别</h3><ul><li><strong>for…in</strong>语句以任意顺序迭代对象的可枚举属性（遍历对象key值）<br><strong>for…of</strong>语句遍历可迭代对象定义迭代属性（遍历数组的值，不能遍历对象）</li></ul><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul><li>进程：一个动态过程，是一个活动的实体。简单来说，一个应用程序的运行可以看做是一个进程</li><li>线程：程序执行流的最小执行单位，是进程中的实际运作单位</li></ul><h3 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h3><h4 id="Hash路由"><a href="#Hash路由" class="headerlink" title="Hash路由"></a>Hash路由</h4><p>Hash路由通过在地址增加<code>#path</code>实现区分页面，当hash发生变化后改变对应组件</p><ul><li>window.addEventListener(‘hashchange’, this.refresh, false)可以监听路由变化</li></ul><h4 id="HTML5-HistoryApi"><a href="#HTML5-HistoryApi" class="headerlink" title="HTML5 HistoryApi"></a>HTML5 HistoryApi</h4><ul><li>window.history.back();  后退</li><li>window.history.forward() 前进</li><li>window.history.go(-4)  退后三个页面</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul><li>Object.assign()</li><li>扩展运算符 …</li></ul><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul><li>JSON.stringify()</li><li>手写循环递归</li></ul><p><strong>手写循环递归</strong><br>1、遍历对象for(var prop in obj)；<br>2、判断是不是原始值；<br>3、判断数组还是对象；<br>4、遍历相应的数组或对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> deepClone(origin, target)&#123;</span><br><span class="line">  var target = target || &#123;&#125;,</span><br><span class="line">      toStr = Object.prototype.toString,</span><br><span class="line">      arrStr = <span class="string">&quot;[object Array]&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span>(var prop <span class="keyword">in</span> origin)&#123;</span><br><span class="line">    <span class="keyword">if</span>(origin.hasOwnProperty(prop))&#123;</span><br><span class="line">      <span class="keyword">if</span>(origin[prop] !== <span class="string">&#x27;null&#x27;</span> &amp;&amp; <span class="built_in">type</span>(origin[prop]) == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(toStr.call(origin[prop]) === arrStr)&#123;</span><br><span class="line">          target[prop] = [];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          target[prop] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        deepClone(origin[prop], target[prop]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        target[prop] = origin[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="箭头函数特点"><a href="#箭头函数特点" class="headerlink" title="箭头函数特点"></a>箭头函数特点</h3><blockquote><p>1.更加简洁的语法<br>2.箭头函数没有自己的this，arguments，super<br>3.箭头函数this只会从自己的作用域链上一层继承this</p></blockquote><blockquote><p><strong>区别：</strong></p><ul><li>1.普通的函数可以匿名，可以具体名函数，但是箭头函数都是匿名函数</li><li>2.箭头函数的this指向不同，在普通函数中，this总是指向调用他的对象，如果作构造函数，this指向创建的对象实例。箭头函数本身不创建this，可以说箭头函数本身没有this，他会声明捕获所在上下文的this，供自己使用</li><li>每个普通函数调用后都具有一个arguments对象，用来存储实际传递的参数</li><li>箭头函数不具有prototype原型对象，而普通函数有</li></ul></blockquote><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><blockquote><ul><li>宏任务：主栈执行的任务，如：定时器、事件绑定、ajax、回调函数、node中fs操作模块等</li><li>微任务：promise，async/await,nextTick等微任务</li></ul></blockquote><blockquote><p>主栈队列就是一个宏任务，每一个宏任务执行完就会执行宏任务中的微任务，直到微任务全部都执行完，才开始执行下一个宏任务。<br>主栈全局任务（宏任务）&gt; 宏任务中的微任务 &gt; 下个宏任务。__,所有promise（微任务）的执行循序优先级高于setTimout定时器</p></blockquote><h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><blockquote><p>总结起来，this的指向规律如下几条：</p><ul><li>在函数体中，指向window</li><li>new方法调用构造函数，构造函数this会被绑定新创建的对象上</li><li>call/apply/bind方法显示调用函数时，函数体之内this会被绑定到指向参数对象上</li><li>通过上下文对象调用函数时，函数体内this会被绑定该对象</li><li>在箭头函数中，this指向有外层（函数或者全局）作用域来决定的。</li></ul></blockquote><h3 id="ES6新增了那些东西"><a href="#ES6新增了那些东西" class="headerlink" title="ES6新增了那些东西"></a>ES6新增了那些东西</h3><ul><li>1、箭头函数</li><li>2、字符串模板</li><li>3、支持模块化（import、export）</li><li>4、类（class）</li><li>5、let、const关键词</li><li>6、一些数组、字符串等内置方法，如：array.form（对象变成数组）,array.of</li><li>7、一些语法，比如扩展运算符、解构、函数默认参数</li><li>8、源编码相关，proxy</li><li>9、set和map数据解构</li><li>10、promise</li></ul><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>函数防抖，指的是短时间内多次触发同一个事件，只执行最后一次，或者只执行最开始的一次，中间的不执行<br>函数节流，指连续触发事件但是在n秒中只执行一次函数，即2n秒内执行2次。节流会稀释函数的执行频率</p><h3 id="作用域、作用域链"><a href="#作用域、作用域链" class="headerlink" title="作用域、作用域链"></a>作用域、作用域链</h3><blockquote><p>作用域</p><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul></blockquote><blockquote><p>作用域链<br>当js中使用一个变量的时候，首先js引擎会尝试在当前作用域下寻找变量，如果没有找到，再到他的上层作用域寻找，以此内推直到找到全局作用域。</p></blockquote><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>要到创建这个函数的那个”域”,作用域中取值,这里强调的是”创建”,而不是调用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x = 10</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;</span><br><span class="line">  console.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> show (f) &#123;</span><br><span class="line">  var x = 20;</span><br><span class="line">  (<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    f() // 10, 而不是20</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">show(fn)</span><br></pre></td></tr></table></figure></p><h3 id="new操作具体干了什么"><a href="#new操作具体干了什么" class="headerlink" title="new操作具体干了什么"></a>new操作具体干了什么</h3><blockquote><ul><li>创建一个空对象</li><li>由this变量引用该对象</li><li>该对象继承该函数的原型（更改原型链指向）</li><li>把属性和方法加入到this引用的对象中</li><li>新创建的对象由this引用，最后隐式的返回this</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Computer (name, price) &#123;</span><br><span class="line">  <span class="comment"># 1.创建一个普通的对象</span></span><br><span class="line">  <span class="comment"># const obj = &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 2.设置该对象的原型对象</span></span><br><span class="line">  <span class="comment"># obj.__proto__ = Computer.prototype</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 3.设置this的指向，指向该obj</span></span><br><span class="line">  <span class="comment"># this --&gt; obj</span></span><br><span class="line">  this.name = name <span class="comment"># &#123;name: &quot;华为&quot;&#125;</span></span><br><span class="line">  this.price == price <span class="comment"># &#123;name: &quot;华为&quot;, price: &#x27;5000&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 4.如果代码里面没有返回对象，那么返回该this</span></span><br><span class="line">  <span class="comment"># return this</span></span><br><span class="line">&#125;</span><br><span class="line">const huwei = new Computer(<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;5000&#x27;</span>)</span><br></pre></td></tr></table></figure><p>JS底层仍然是一门基于原型的语言，这一点是不会改变的，现在不会变，未来，也不会变</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var Farther = &#123;name: <span class="string">&#x27;farther&#x27;</span>&#125;</span><br><span class="line">var Son = Object.create(Farther)</span><br></pre></td></tr></table></figure><h3 id="原型链原理"><a href="#原型链原理" class="headerlink" title="原型链原理"></a>原型链原理</h3><ul><li>每个实例对象都有一个<code>__proto__</code>属性，该属性指向自己的原型对象prototype</li><li>每一个构造函数都有一个<code>protoype</code>属性，该属性指向实例对象的原型对象</li><li>原型对象里的<code>contructor</code>指向构造函数本身</li></ul><p><img src="https://raw.githubusercontent.com/riceCk/riceBlog/master/images/prototype.png" alt="原型链"></p><h4 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Computer</span></span>()&#123;&#125;</span><br><span class="line">const c = new Computer()</span><br><span class="line">console.log(c.__proto__ === Computer.prototype);</span><br><span class="line">console.log(c.constructor === Computer)</span><br><span class="line">console.log(c.constructor === Computer.prototype.constructor)</span><br><span class="line">console.log(<span class="string">&#x27;------------&#x27;</span>)</span><br><span class="line">console.log([].__proto__ === Array.prototype)</span><br><span class="line">console.log([].constructor === Array)</span><br></pre></td></tr></table></figure><h4 id="日常实战"><a href="#日常实战" class="headerlink" title="日常实战"></a>日常实战</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议</span></span><br><span class="line">class myNum extends Number &#123;</span><br><span class="line">    constructor(...args) &#123;</span><br><span class="line">        super(args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">zhangsan</span></span> () &#123;</span><br><span class="line">        console.log(11111)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const i = new myNum()</span><br><span class="line">i.zhangsan()</span><br><span class="line"><span class="comment"># 不建议，被称为猴子补丁-“不是你的对象别动手动脚”</span></span><br><span class="line">Number.prototype.zhangsan = <span class="function"><span class="title">function</span></span> ()&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="以jQuery源码为例"><a href="#以jQuery源码为例" class="headerlink" title="以jQuery源码为例"></a>以jQuery源码为例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = window.$ = jQuery</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> jQuery (str) &#123;</span><br><span class="line">  <span class="built_in">return</span> new jQuery.prototype.init(str)</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype.init.prototype = jQuery.prototype</span><br><span class="line">jQuery.prototype.init = <span class="keyword">function</span> (str) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">return</span> this.</span><br><span class="line">&#125;</span><br><span class="line">jQuery.prototype.css = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br><span class="line">jQuery.protoype.html = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="声明与实例化"><a href="#声明与实例化" class="headerlink" title="声明与实例化"></a>声明与实例化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类的声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Animal</span></span>()&#123;</span><br><span class="line">  this.name = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ES6中的class的声明</span></span><br><span class="line">class <span class="function"><span class="title">Animal2</span></span>()&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>()&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">new Animal();</span><br><span class="line">new Animal2();</span><br></pre></td></tr></table></figure><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p><strong>1、借助构造函数实现继承</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.lasName = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123;</span><br><span class="line">  this.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.newName = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>()&#123;</span><br><span class="line">  Parent.call(this);</span><br><span class="line">  this.type = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>特点</strong></p><ul><li>call/apply能改函数运行的上下文，从而实现继承，但是<code>Parent</code>如果定义原型上的方法，<code>Child</code>是无法取到的</li><li><code>Child</code>只能取到<code>Parent</code>函数中的属性，但是取不到<code>Parent</code>的原型属性</li></ul><p><strong>2、正则共享原型</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.lasName = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123;</span><br><span class="line">  this.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.newName = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>()&#123;</span><br><span class="line">  this.type = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var child = new Child()</span><br><span class="line">var parent = new Parent()</span><br><span class="line">parent.name = <span class="string">&#x27;ccc&#x27;</span></span><br></pre></td></tr></table></figure><br><strong>特点：</strong><br>1、改变<code>Child</code>原型从而继承<code>parent</code>原型上的属性<br>2、Child上定义的原型，在实例上就取不到了，因为已经改变了自身的原型指向。<br>3、此继承了<code>Parent</code>上的原型方法和函数自身属性，<code>child</code>修改原型上面属性时，<code>Parent</code>原型上方法会随之也改变，这是我们不希望的。</p><p><strong>3、复合方法</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123;</span><br><span class="line">  this.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>()&#123;</span><br><span class="line">  Parent.call(this);</span><br><span class="line">  this.type = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = new Parent();</span><br></pre></td></tr></table></figure><br><strong>特点：</strong><br>1、<code>Parent</code>被new执行了两次，没有必要的事<br>2、<code>Child</code>改变原型的方法，<code>Parent</code>不会随之改变</p><p><strong>4、圣杯模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.lasName = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Parent</span></span>()&#123;</span><br><span class="line">  this.name = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">  this.play = [1,2]</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype.newName = <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Child</span></span>()&#123;</span><br><span class="line">  Parent.call(this);</span><br><span class="line">  this.type = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> inherit (Target, Origin)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">F</span></span>()&#123;&#125;;</span><br><span class="line">  F.prototype = Origin.prototype;</span><br><span class="line">  Target.prototype = new F;</span><br><span class="line">  Target.prototype.constructor = Target</span><br><span class="line">  Target.prototype.uber = Object.prototype;</span><br><span class="line">&#125;</span><br><span class="line">inherit(Child, Parent);</span><br><span class="line">var a = new Child()</span><br><span class="line">Child.prototype.lasName=<span class="string">&#x27;ccc&#x27;</span></span><br></pre></td></tr></table></figure><br><strong>特点</strong><br><code>Child</code>定义的自身原型无效的，实例无法访问</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="创建上下文阶段"><a href="#创建上下文阶段" class="headerlink" title="创建上下文阶段"></a>创建上下文阶段</h4><ul><li>1.确定函数的形参（并赋值）</li><li>2.函数环境会初始化创建Arguments对象（并赋值）</li><li>3.确定普通字面量形式的函数声明（并赋值）</li><li>4.变量声明，函数表达式声明（非赋值）</li><li>在进行变量声明的时候，如果发现改变量名已经存在，则不会再去声明</li></ul><p><strong>举个栗子</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const foo = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(a) <span class="comment"># undefined </span></span><br><span class="line">  console.log(c) <span class="comment"># function c () &#123;&#125;</span></span><br><span class="line">  var a = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">  var bar = <span class="keyword">function</span> <span class="function"><span class="title">privateB</span></span> ()&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">&quot;World&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">c</span></span> ()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 下面解释了，a打印为什么是undefined</span></span><br><span class="line"><span class="comment"># foo上下文分为两个阶段：1.创建阶段  2.执行阶段</span></span><br><span class="line"><span class="comment"># 1.创建上下文阶段</span></span><br><span class="line">  fooExecutionContext = &#123;</span><br><span class="line">    vo = &#123;</span><br><span class="line">      <span class="comment"># 1.确定函数的形参（并赋值）</span></span><br><span class="line">      i: 10,</span><br><span class="line">      <span class="comment"># 2.函数环境会初始化创建Arguments对象（并赋值）</span></span><br><span class="line">      arguments: &#123;0: 10, length: 1&#125;,</span><br><span class="line">      <span class="comment"># 3.确定普通字面量形式的函数声明（并赋值）</span></span><br><span class="line">      c: 指向c那个函数</span><br><span class="line">      <span class="comment"># 4.变量声明，函数表达式声明（非赋值）</span></span><br><span class="line">      a: undefined</span><br><span class="line">      bar: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    this, <span class="comment"># 指向</span></span><br><span class="line">    scope, <span class="comment"># 作用域</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># 2.执行代码</span></span><br><span class="line">  vo = &#123;</span><br><span class="line">    i: 10,</span><br><span class="line">    arguments: &#123;0: 10, length: 1&#125;,</span><br><span class="line">    c: 指向c那个函数</span><br><span class="line">    a: <span class="string">&quot;Hello&quot;</span> <span class="comment"># 赋值</span></span><br><span class="line">    b: privateB 函数 <span class="comment"># 赋值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h3><p>js的执行分为:解释和执行两个阶段,执行上下文最明显的就是this的指向是执行时确定的,而作用域访问的变量是编写代码结构确定的(静态的),<br><strong>执行上下文在运行时确定,随时可能改变,作用域在定义时就确定,并不会改变</strong></p><p><strong>解释阶段</strong></p><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><p><strong>执行阶段</strong></p><ul><li>创建执行上下文</li><li>执行函数代码</li><li>垃圾回收</li></ul><h3 id="垃圾回收与内存泄漏"><a href="#垃圾回收与内存泄漏" class="headerlink" title="垃圾回收与内存泄漏"></a>垃圾回收与内存泄漏</h3><p>js具有<strong>自动垃圾回收机制</strong>，会固定的时间间隔周期性的执行<br>1.标记清除方式</p><blockquote><p>工作原理：当变量进入环境时，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”就是回收内存</p></blockquote><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><h4 id="捕获和冒泡"><a href="#捕获和冒泡" class="headerlink" title="捕获和冒泡"></a>捕获和冒泡</h4><p><strong>冒泡：</strong>即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）<br>目标元素 -&gt; … -&gt; body -&gt; document -&gt; window<br><strong>捕获：</strong>不太具体的节点应该更早接收事件，而最具体的节点应该最后接收事件<br>window -&gt; document -&gt; html标签 -&gt; body -&gt; … -&gt;目标元素</p><h4 id="DOM事件流采用捕获-冒泡"><a href="#DOM事件流采用捕获-冒泡" class="headerlink" title="DOM事件流采用捕获 + 冒泡"></a>DOM事件流采用捕获 + 冒泡</h4><p>捕获 -&gt; 目标阶段 -&gt; 冒泡</p><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><ul><li>value：设置属性值，默认值undefined;</li><li>writable：设置属性值可写，默认为true</li><li>enumerable: 设置属性是否可枚举，即是否使用for/in语句或object.key函数遍历访问，默认true</li><li>configurable：设置是否可设置属性特性，默认为true。如果false，将无法删除该属性，不能够修改属性值，也不能修改属性的属性描述符</li><li>get: 取值函数，默认为undefined</li><li>set：存值函数，默认为undefined</li></ul><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, <span class="string">&#x27;x&#x27;</span>, &#123;</span><br><span class="line">    // value: 100, <span class="comment"># value 和get/set 不用同时设置</span></span><br><span class="line">    // writable: <span class="literal">true</span>, <span class="comment"># writable 和get/set 不用同时设置</span></span><br><span class="line">    <span class="function"><span class="title">get</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.value || 100</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span> (val) &#123;</span><br><span class="line">        console.log(val)</span><br><span class="line">        this.value = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript-面试题汇总&quot;&gt;&lt;a href=&quot;#JavaScript-面试题汇总&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 面试题汇总&quot;&gt;&lt;/a&gt;JavaScript 面试题汇总&lt;/h2&gt;&lt;h3 id=&quot;typeof、in</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之三CSS</title>
    <link href="http://yoursite.com/2023/04/05/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/3.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%B8%89CSS/"/>
    <id>http://yoursite.com/2023/04/05/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/3.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%B8%89CSS/</id>
    <published>2023-04-05T01:48:00.000Z</published>
    <updated>2024-10-14T03:06:58.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Css面试题"><a href="#Css面试题" class="headerlink" title="Css面试题"></a>Css面试题</h1><h2 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h2><blockquote><ul><li>10000: !important</li><li>1000: 内联样式，外联样式</li><li>100: ID选择器</li><li>10: 类选择器、伪类选择器、属性选择器</li><li>1: 标签选择器、伪元素选择器</li><li>0：通配选择器、兄弟、父子选择器</li></ul></blockquote><h2 id="分析知识模块"><a href="#分析知识模块" class="headerlink" title="分析知识模块"></a>分析知识模块</h2><ul><li>布局</li><li>定位</li><li>图文样式</li><li>响应式</li><li>CSS3</li></ul><h2 id="盒子模型的宽度如何计算"><a href="#盒子模型的宽度如何计算" class="headerlink" title="盒子模型的宽度如何计算"></a>盒子模型的宽度如何计算</h2><p>W3C：width = content<br>IE： width = content+padding+border (横向相关)</p><h2 id="margin纵向重叠问题"><a href="#margin纵向重叠问题" class="headerlink" title="margin纵向重叠问题"></a>margin纵向重叠问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 如下代码：AAA 和 BBB 之间的距离是多少？</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    line-height: 1;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    margin-bottom: 15px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;AAA&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;BBB&lt;/p&gt;</span><br></pre></td></tr></table></figure><ul><li>相邻元素的margin-top 和 margin-bottom会发生重叠</li><li>空白内容的<code>&lt;p&gt;&lt;/p&gt;</code>也会重叠（相当于忽略不计）</li><li>答案：15px</li></ul><h2 id="margin-负值问题"><a href="#margin-负值问题" class="headerlink" title="margin 负值问题"></a>margin 负值问题</h2><p>对margin的top、left、right、bottom设置负值，有什么效果？<br>反方向移动p</p><h2 id="BFC理解和应用"><a href="#BFC理解和应用" class="headerlink" title="BFC理解和应用"></a>BFC理解和应用</h2><ul><li>Block format context, 块级格式化上下文</li><li>一块独立渲染区域，内部元素的渲染不会影响边界以外的元素</li></ul><h4 id="形成BFC的常见条件"><a href="#形成BFC的常见条件" class="headerlink" title="形成BFC的常见条件"></a>形成BFC的常见条件</h4><ul><li>float 不是none</li><li>position 是absolute或者fixed</li><li>overflow不是visible</li><li>display是flex inline-block等</li></ul><h2 id="float布局的问题，以及clearfix"><a href="#float布局的问题，以及clearfix" class="headerlink" title="float布局的问题，以及clearfix"></a>float布局的问题，以及clearfix</h2><h4 id="圣杯布局和双飞翼布局的目的"><a href="#圣杯布局和双飞翼布局的目的" class="headerlink" title="圣杯布局和双飞翼布局的目的"></a>圣杯布局和双飞翼布局的目的</h4><ul><li>三栏布局，中间一栏最先加载和渲染（内容重要）</li><li>两侧内容固定，中间内容随着宽度自适应</li><li>一般用于PC网页</li></ul><h4 id="圣杯布局和双飞翼布局的技术总结"><a href="#圣杯布局和双飞翼布局的技术总结" class="headerlink" title="圣杯布局和双飞翼布局的技术总结"></a>圣杯布局和双飞翼布局的技术总结</h4><ul><li>使用float布局</li><li>两侧使用margin负值，以便和中间内容横向重叠</li><li>防止中间内容被两侧覆盖，一个用padding一个用margin</li></ul><h2 id="flex画筛子"><a href="#flex画筛子" class="headerlink" title="flex画筛子"></a>flex画筛子</h2><ul><li>flex-direction</li><li>justify-content</li><li>align-items</li><li>flex-wrap</li><li>align-self</li></ul><h2 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h2><ul><li>flex-grow 一个数字，进行扩展</li><li>flex-shrink 一个数字，进行收缩</li><li>flex-basis 长度，合法值：”auto”,”%”,”px”,”em”,或者任意长度的数据</li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p><strong>四种定位区别</strong></p><ul><li>static是默认</li><li>relative 相对定位 相对于自身原位置进行偏移</li><li>absolute 绝对定位 相对于最近已定位的祖先元素</li><li>fixed 固定定位的元素会相对于视窗口对位</li></ul><h3 id="absolute-和-relative-分别依据什么定位"><a href="#absolute-和-relative-分别依据什么定位" class="headerlink" title="absolute 和 relative 分别依据什么定位"></a>absolute 和 relative 分别依据什么定位</h3><ul><li>relative 依据自身定位</li><li>absolute 依据最近一层定位元素</li></ul><h4 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h4><ul><li>absoulte relative fixed</li><li>body</li></ul><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul><li>inline元素：text-align:center</li><li>block元素：margin: auto;</li><li>absolute元素：left:50% + margin-left负值</li></ul><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ul><li>inline元素：line-height的值等于height值</li><li>absolute元素：top：50% + margin-top负值</li><li>absoulte元素：transform(-50%, -50%)</li><li>absoulte元素：top,left,right,bottom = 0;margin: auto</li></ul><h2 id="line-height如何继承"><a href="#line-height如何继承" class="headerlink" title="line-height如何继承"></a>line-height如何继承</h2><ul><li>写具体数值，如30px，则继承该值</li><li>写比例，如2/1.5,则继承改比例</li><li>写百分比，如200%,则继承计算出来的值</li></ul><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><h3 id="rem是个长度单位"><a href="#rem是个长度单位" class="headerlink" title="rem是个长度单位"></a>rem是个长度单位</h3><ul><li>px，绝对长度单位，最常用</li><li>em，相对长度单位，相对于父元素，不常用</li><li>rem，相对长度单位，相对于根元素（如：font-size: 18px），常用于响应式布局</li></ul><h4 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw-vh"></a>vw-vh</h4><ul><li>rem的弊端</li><li>网页视口尺寸</li><li>vw/vh</li></ul><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><ul><li>给父级div定义height属性</li><li>最后一个浮动元素后添加一个空的div标签，并添加<strong>clear：both</strong>样式</li><li>包含浮动元素的父级标签添加<strong>overflow:hidden</strong>或者<strong>overflow:auto</strong></li><li>使用 <strong>:after</strong>伪元素，使用clear属性清除浮动</li></ul><h2 id="移动端有哪些常见的问题，都是怎么解决的？"><a href="#移动端有哪些常见的问题，都是怎么解决的？" class="headerlink" title="移动端有哪些常见的问题，都是怎么解决的？"></a>移动端有哪些常见的问题，都是怎么解决的？</h2><p>H5页面窗口自动调整到设备宽度，并禁止用户缩放页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Css面试题&quot;&gt;&lt;a href=&quot;#Css面试题&quot; class=&quot;headerlink&quot; title=&quot;Css面试题&quot;&gt;&lt;/a&gt;Css面试题&lt;/h1&gt;&lt;h2 id=&quot;选择器的权重&quot;&gt;&lt;a href=&quot;#选择器的权重&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>技术面之二HTML知识汇总</title>
    <link href="http://yoursite.com/2023/04/02/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/2.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%BA%8CHTML/"/>
    <id>http://yoursite.com/2023/04/02/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/2.%E6%8A%80%E6%9C%AF%E9%9D%A2%E4%B9%8B%E4%BA%8CHTML/</id>
    <published>2023-04-02T01:48:00.000Z</published>
    <updated>2024-09-18T08:03:07.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML知识汇总"><a href="#HTML知识汇总" class="headerlink" title="HTML知识汇总"></a>HTML知识汇总</h2><h3 id="html语义化"><a href="#html语义化" class="headerlink" title="html语义化"></a>html语义化</h3><p>html语义化就是用适合的标签和合适的内容</p><h4 id="语义化好处"><a href="#语义化好处" class="headerlink" title="语义化好处"></a><strong>语义化好处</strong></h4><blockquote><ul><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。</li><li>方便其他设备（如屏幕阅读器、盲人阅读器、移动设备）更好的解析页面。</li><li>使代码更具可读性，便于团队开发和维护</li><li>网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看</li></ul></blockquote><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a><strong>语义化标签</strong></h4><blockquote><ul><li>header footer nav(导航链接区域)</li><li>aside 通常被包含在article元素中作为主要内容的附属信息部分</li><li>section section元素代表文档中的“节”或“段”</li><li>article article代表一个在文档，页面或者网站中自成一体的内容,比如论坛帖子</li><li>h1 - h6 标题，根据级别依次递减 h1一个页面最好只有一个p 内容段落</li></ul></blockquote><h3 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h3><h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><blockquote><ul><li>不会独占一行,相邻的行内元素会排列在同一行里,直到一行排不下,才会换行</li><li>行内元素设置width,height属性无效</li><li>行内元素的margin和padding只在水平方向有效果</li></ul></blockquote><p><strong>标签：</strong> a img input label select strong textarea</p><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><blockquote><ul><li>会独占一行,默认情况下,其宽度自动填满其父元素宽度</li><li>块级元素可以设置width,height属性.</li><li>块级元素即使设置了宽度,仍然是独占一行.</li><li>块级元素可以设置margin和padding属性</li></ul></blockquote><p><strong>标签：</strong> div p form h1-h6 ul ol</p><h4 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h4><p>结合的行内和块级的优点，既可以设置长宽，可以让padding和margin生效，又可以和其他行内元素并排</p><p>html如何做SEO优化</p><blockquote><ul><li>尽量简单，导航最好不要超过3级</li><li>控制首页链接数量</li><li>网站首页是权重最高的地方，如果首页链接太少,影响网站收录数量。太多影响用户体验，也会降低网站首页的权重，收录效果也不好</li><li>图片必须添加alt和title，在每个菜单考虑增加面包屑导航</li><li>控制页面的大小，减少http请求，提高网站的加载速度</li><li>突出重要内容，合理的设计网站title、description和keywords</li><li>尽量让代码语义化，用正确的标签做正确的事</li></ul></blockquote><h3 id="h5语义化标签"><a href="#h5语义化标签" class="headerlink" title="h5语义化标签"></a>h5语义化标签</h3><p><img src="https://raw.githubusercontent.com/riceCk/riceBlog/master/images/html5-layout.jpg" alt="h5语义化标签"></p><h4 id="title："><a href="#title：" class="headerlink" title="title："></a>title：</h4><p>简短、描述性、唯一（提升搜索引擎排名）</p><h4 id="hn："><a href="#hn：" class="headerlink" title="hn："></a>hn：</h4><p>h1~h6分级标题，用于创建页面信息的层级关系。对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1。</p><h4 id="header："><a href="#header：" class="headerlink" title="header："></a>header：</h4><p>页眉通常包括网站标志、主导航、全站链接以及搜索框，也适合对页面内部一组介绍性或导航性内容进行标记。</p><h4 id="nav："><a href="#nav：" class="headerlink" title="nav："></a>nav：</h4><p>标记导航，仅对文档中重要的链接群使用。html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;HTML 5&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;CSS3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;JavaScript&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure></p><h4 id="main："><a href="#main：" class="headerlink" title="main："></a>main：</h4><p>页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。</p><h4 id="article："><a href="#article：" class="headerlink" title="article："></a>article：</h4><p>包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器。article可以嵌套article，只要里面的article与外面的是部分与整体的关系。</p><h4 id="section："><a href="#section：" class="headerlink" title="section："></a>section：</h4><p>具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。</p><h4 id="aside："><a href="#aside：" class="headerlink" title="aside："></a>aside：</h4><p>指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。如果放在main内，应该与所在内容密切相关。</p><h4 id="footer："><a href="#footer：" class="headerlink" title="footer："></a>footer：</h4><p>页脚，只有当父级是body时，才是整个页面的页脚。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">    COPYRIGHT@小北</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTML知识汇总&quot;&gt;&lt;a href=&quot;#HTML知识汇总&quot; class=&quot;headerlink&quot; title=&quot;HTML知识汇总&quot;&gt;&lt;/a&gt;HTML知识汇总&lt;/h2&gt;&lt;h3 id=&quot;html语义化&quot;&gt;&lt;a href=&quot;#html语义化&quot; class=&quot;header</summary>
      
    
    
    
    <category term="2023前端面试梳理" scheme="http://yoursite.com/categories/2023%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%A2%B3%E7%90%86/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>3.react hooks</title>
    <link href="http://yoursite.com/2022/11/15/react/3.React%20Hooks/"/>
    <id>http://yoursite.com/2022/11/15/react/3.React%20Hooks/</id>
    <published>2022-11-15T06:05:00.000Z</published>
    <updated>2024-08-21T06:20:36.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h2><h3 id="使用hooks理由"><a href="#使用hooks理由" class="headerlink" title="使用hooks理由"></a>使用hooks理由</h3><blockquote><ul><li>1.高阶组件为了复用，导致代码层级复杂</li><li>2.生命周期的复杂</li><li>3.写成fucntion组件，无状态组件，因为需要状态，又改成了class成本高</li></ul></blockquote><h3 id="1-useState-保存组件状态"><a href="#1-useState-保存组件状态" class="headerlink" title="1.useState(保存组件状态)"></a>1.useState(保存组件状态)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, setstate] = useState(initialState)</span><br></pre></td></tr></table></figure><p><strong>案例</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default <span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">    const [text, setText] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;text&#125; onChange=&#123;(e) =&gt; setText(e.target.value)&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">            console.log(text)</span><br><span class="line">        &#125;&#125;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-useEffect-处理回调"><a href="#2-useEffect-处理回调" class="headerlink" title="2.useEffect 处理回调"></a>2.useEffect 处理回调</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    return () =&gt; &#123;&#125;</span><br><span class="line">&#125;, [依赖的状态；空数组，表示不依赖])</span><br></pre></td></tr></table></figure><p><strong>案例1</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const [list, setlist] = useState([])</span><br><span class="line"><span class="comment"># 只会请求一遍</span></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    axios.get(&#x27;/test.json&#x27;).then(res =&gt; &#123;</span><br><span class="line">        setlist(res.data.data.films)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, [])</span><br><span class="line">return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        App</span><br><span class="line">        &#123;</span><br><span class="line">            list.map(item =&gt; (</span><br><span class="line">                &lt;li key=&#123;item.filmId&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br><span class="line">            ))</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><strong>案例2</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const [name, setName] = useState(<span class="string">&#x27;kerwin&#x27;</span>)</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    setName(name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>))</span><br><span class="line">&#125;, [name]) <span class="comment"># 依赖name更新</span></span><br><span class="line"><span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        App - &#123;name&#125;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setName(<span class="string">&#x27;xiaoming&#x27;</span>)&#125;&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-hooks&quot;&gt;&lt;a href=&quot;#react-hooks&quot; class=&quot;headerlink&quot; title=&quot;react hooks&quot;&gt;&lt;/a&gt;react hooks&lt;/h2&gt;&lt;h3 id=&quot;使用hooks理由&quot;&gt;&lt;a href=&quot;#使用hooks理</summary>
      
    
    
    
    <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>2.react 生命周期</title>
    <link href="http://yoursite.com/2022/10/12/react/2.react%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2022/10/12/react/2.react%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-10-12T02:28:00.000Z</published>
    <updated>2024-08-21T06:20:36.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h2><h3 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="1.初始化阶段"></a>1.初始化阶段</h3><blockquote><ul><li><del>componentWillMount</del>: render之前最后一次修改的机会 （16.2版本之后建议弃用， <strong>UNSAFE_componentWillMount</strong>替代，否则控制台警告）</li><li>render: 只访问this.props和this.state，不允许修改状态和DOM输出</li><li>componentDidMount: 成功render并渲染完成真实DOM之后触发，可以修改DOM<br>(1) 数据请求axios<br>(2) 订阅函数调用<br>(3) setInterval<br>(4)基于创建完的dom进行初始化…</li></ul></blockquote><h3 id="2-运行中阶段"><a href="#2-运行中阶段" class="headerlink" title="2.运行中阶段"></a>2.运行中阶段</h3><blockquote><ul><li><del>componentWillReceiveProps</del>: 父组件修改属性触发子组件钩子函数(<strong>UNSAFE_componentWillReceiveProps</strong> 控制台不会警告)</li><li>shouldComponentUpdate: 返回false会阻止render调用</li><li><del>componentWillUpdate</del>:  更新前的钩子，不能修改属性状态(<strong>UNSAFE_componentWillUpdate</strong>替代，否则控制台警告)</li><li>render: 只能访问this.props和this.state，不允许修改状态和DOM输出</li><li>componentDidUpdate: 更新后的钩子 可以修改DOM</li></ul></blockquote><h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h4><p>父组件修改属性触发子组件钩子函数 <strong>UNSAFE_componentWillReceiveProps</strong></p><blockquote><ul><li>1.最先获取父组件传来的属性，可以利用属性进行ajax或者逻辑处理</li><li>2.把属性转化成孩纸自己的状态</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        title: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &lt;div&gt;child &#123;this.state.title&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps (nextProps) &#123;</span><br><span class="line">         this.setState(&#123;</span><br><span class="line">            title: nextProps.text + <span class="string">&#x27;kevint&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        text: <span class="string">&#x27;11111111111111&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">         &#123;this.state.text&#125;</span><br><span class="line">         &lt;button onClick=&#123;() =&gt; this.setState(&#123;text: 222222222222&#125;)&#125;&gt;点击&lt;/button&gt;</span><br><span class="line">        &lt;Child text=&#123;this.state.text&#125;&gt;&lt;/Child&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="componentDidUpdate-更新后的钩子-可以修改DOM"><a href="#componentDidUpdate-更新后的钩子-可以修改DOM" class="headerlink" title="componentDidUpdate 更新后的钩子 可以修改DOM"></a>componentDidUpdate 更新后的钩子 可以修改DOM</h4><p><strong>接口两个参数，修改前的props和state数据</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate (prevProps, prevtate) &#123;</span><br><span class="line">    console.log(oldState, newState)</span><br><span class="line">    console.log(this.state.list)</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"><span class="comment">#### shouldComponentUpdate 返回false会阻止render调用</span></span><br><span class="line"><span class="built_in">return</span> <span class="literal">false</span> render函数不更新，<span class="built_in">return</span> <span class="literal">true</span> render函数更新</span><br><span class="line">接受两个参数，新的props参数，新的state参数</span><br><span class="line">```bash</span><br><span class="line">shouldComponentUpdate (nextProps, nextState) &#123;</span><br><span class="line">    console.log(nextProps, nextState)</span><br><span class="line">    <span class="keyword">if</span> (this.state.myname === <span class="string">&#x27;xiaoming&#x27;</span>) <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3.销毁阶段"></a>3.销毁阶段</h3><blockquote><ul><li>componentWillUnmount: 在删除组件之前进行清理操作，比如计时器和事件监听器</li></ul></blockquote><h3 id="4-老生命周期的问题"><a href="#4-老生命周期的问题" class="headerlink" title="4.老生命周期的问题"></a>4.老生命周期的问题</h3><p>（1）componentWillMount, 在ssr中这个方法将会被多次调用，所以会重复触发多遍，同时在这里如果绑定事件，将无法解绑，导致内存泄漏，变的不够安全高效逐步废弃<br>（2）componentWillReceiveProps 外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求<br>（3）componentWillUpdate，更新前记录DOM状态，可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致状态不可信</p><h3 id="5-新生命周期的替代"><a href="#5-新生命周期的替代" class="headerlink" title="5.新生命周期的替代"></a>5.新生命周期的替代</h3><h4 id="1-getDerivedStateFromProps-第一次的初始化组件以及后续的更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的state，返回null则说明不需要再这里更新state"><a href="#1-getDerivedStateFromProps-第一次的初始化组件以及后续的更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的state，返回null则说明不需要再这里更新state" class="headerlink" title="(1) getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的state，返回null则说明不需要再这里更新state"></a>(1) getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的state，返回null则说明不需要再这里更新state</h4><p>getDerivedStateFromProps 总不能进行异步处理</p><h5 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    myName: <span class="string">&#x27;adsafasd&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 初始化，或者数据改变，都会触发，return返回的参数会合并到state上面</span></span><br><span class="line">static getDerivedStateFromProps (nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        myName: nextState.myName.substring(0, 1).toUpperCase() + nextState.myName.substring(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; this.setState(&#123;myName: <span class="string">&#x27;fdgsdfgdfs&#x27;</span>&#125;)&#125;&gt;点击&lt;/button&gt;</span><br><span class="line">            &#123;this.state.myName&#125;</span><br><span class="line">            &#123;this.state.age&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5><blockquote><ul><li>1.getDerivedStateFromProps 中不能进行异步处理，所以需要进行状态管理，配合componentDidUpdate触发</li><li>2.componentDidUpdate 需要异步请求前，需要加个锁</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class FilmList extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        list: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="built_in">type</span>: null</span><br><span class="line">    &#125;</span><br><span class="line">    static getDerivedStateFromProps (nextProps) &#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;<span class="built_in">type</span>: nextProps.<span class="built_in">type</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    async componentDidUpdate (prevProps, prevtate) &#123;</span><br><span class="line">        console.log(this.state.type, <span class="string">&#x27;stte.type&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (this.state.type === prevProps.<span class="built_in">type</span>) <span class="built_in">return</span></span><br><span class="line">        <span class="comment"># 假装下面代码是 接口回调</span></span><br><span class="line">        <span class="comment"># await</span></span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            list: this.state.type + <span class="string">&#x27;2222222222222&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;this.props.type&#125;</span><br><span class="line">                &lt;p&gt;&#123;this.state.list&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="built_in">type</span>: 1</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li onClick=&#123;() =&gt; this.setState(&#123;<span class="built_in">type</span>: 1&#125;)&#125;&gt;正在热映&lt;/li&gt;</span><br><span class="line">            &lt;li onClick=&#123;() =&gt; this.setState(&#123;<span class="built_in">type</span>: 2&#125;)&#125;&gt;即将上映&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FilmList <span class="built_in">type</span>=&#123;this.state.type&#125;&gt;&lt;/FilmList&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-getSnapshotBeforeUpdate-取代componentWillUpdate-触发时间为update发生时候，在render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数"><a href="#2-getSnapshotBeforeUpdate-取代componentWillUpdate-触发时间为update发生时候，在render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数" class="headerlink" title="(2) getSnapshotBeforeUpdate 取代componentWillUpdate, 触发时间为update发生时候，在render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数"></a>(2) getSnapshotBeforeUpdate 取代componentWillUpdate, 触发时间为update发生时候，在render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数</h4><p><strong>案例1</strong><br>必须返回一个值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getSnapshotBeforeUpdate</span></span> () &#123;</span><br><span class="line">    console.log(3333333333)</span><br><span class="line">    <span class="built_in">return</span> 1111</span><br><span class="line">&#125;</span><br><span class="line">componentDidUpdate (prevProps, prevState, value) &#123;</span><br><span class="line">    console.log(prevProps, prevState, value) <span class="comment"># value -&gt; 111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>案例2</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    list: [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">&#125;</span><br><span class="line">myref = React.createRef()</span><br><span class="line"><span class="function"><span class="title">getSnapshotBeforeUpdate</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 获取容器高度</span></span><br><span class="line">    <span class="built_in">return</span> this.myref.current.scrollHeight</span><br><span class="line">&#125;</span><br><span class="line">componentDidUpdate (prevProps, prevState, value) &#123;</span><br><span class="line">    this.myref.current.scrollTop += this.myref.current.scrollHeight - value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                    list: [...[11, 12, 13, 14, 15, 16, 17, 18], ...this.state.list]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                收邮件</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;h1&gt;邮箱应用&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div style=&#123;&#123; height: <span class="string">&#x27;200px&#x27;</span>, overflow: <span class="string">&#x27;auto&#x27;</span> &#125;&#125; ref=&#123;this.myref&#125;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        this.state.list.map(item =&gt;</span><br><span class="line">                            &lt;li style=&#123;&#123; height: <span class="string">&#x27;100px&#x27;</span>, background: <span class="string">&#x27;red&#x27;</span> &#125;&#125; key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-react中性能优化的方案"><a href="#6-react中性能优化的方案" class="headerlink" title="6.react中性能优化的方案"></a>6.react中性能优化的方案</h3><h4 id="1-shouldComponentUpdate"><a href="#1-shouldComponentUpdate" class="headerlink" title="1.shouldComponentUpdate"></a>1.shouldComponentUpdate</h4><p>控制组件自身或者子组件是否需要更新，尤其在子组件非常多的情况下，需要进行优化</p><h4 id="2-PureComponent"><a href="#2-PureComponent" class="headerlink" title="2.PureComponent"></a>2.PureComponent</h4><p><strong>PureComponent</strong>会帮你比较新的<code>props</code>跟旧的<code>props</code>,新的<code>state</code>和老的<code>state</code>（值相等，或者对象含有相同的属性，且属性值相等），决定<strong>shouldComponentUpdate</strong>返回true或者false，从而决定要不要呼叫render function。</p><p><strong>注意：</strong><br>如果你的state或props【永远都不会变】，那<strong>PureComponent</strong>并不会比较快，因为shallowEqual也需要花时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; PureComponent, Component &#125; from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default class App extends PureComponent &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        myname: <span class="string">&#x27;kerwin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># PureComponent 相当于下面函数注释打开</span></span><br><span class="line">    <span class="comment"># shouldComponentUpdate (nextProps, nextState) &#123;</span></span><br><span class="line">    <span class="comment">#     console.log(nextProps, nextState)</span></span><br><span class="line">    <span class="comment">#     if (this.state.myname === &#x27;xiaoming&#x27;) return false</span></span><br><span class="line">    <span class="comment">#     return true</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="comment"># 如果用来PureComponent 不会多次执行render</span></span><br><span class="line">        console.log(22222222)</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        myname: <span class="string">&#x27;xiaoming&#x27;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;&gt;click&lt;/button&gt;</span><br><span class="line">                &#123;this.state.myname&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-react之swiper轮播组件"><a href="#7-react之swiper轮播组件" class="headerlink" title="7.react之swiper轮播组件"></a>7.react之swiper轮播组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from <span class="string">&#x27;react&#x27;</span></span><br><span class="line">import Swiper, &#123;Navigation, Pagination&#125; from <span class="string">&#x27;swiper&#x27;</span></span><br><span class="line">import <span class="string">&#x27;swiper/swiper-bundle.min.css&#x27;</span></span><br><span class="line">Swiper.use([Navigation, Pagination])</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        list: [<span class="string">&quot;1111&quot;</span>, <span class="string">&quot;2222&quot;</span>, <span class="string">&quot;3333&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span></span> () &#123;</span><br><span class="line">        <span class="comment"># 同步</span></span><br><span class="line">        new Swiper (<span class="string">&#x27;.swiper&#x27;</span>, &#123;</span><br><span class="line">            <span class="comment"># direction: &#x27;vertical&#x27;, # 垂直切换选项</span></span><br><span class="line">            <span class="comment"># loop: true, # 循环模式选项</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果需要分页器</span></span><br><span class="line">            pagination: &#123;</span><br><span class="line">              el: <span class="string">&#x27;.swiper-pagination&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果需要前进后退按钮</span></span><br><span class="line">            navigation: &#123;</span><br><span class="line">              nextEl: <span class="string">&#x27;.swiper-button-next&#x27;</span>,</span><br><span class="line">              prevEl: <span class="string">&#x27;.swiper-button-prev&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果需要滚动条</span></span><br><span class="line">            scrollbar: &#123;</span><br><span class="line">              el: <span class="string">&#x27;.swiper-scrollbar&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;)        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 如果是异步，可以在这边new Swiper</span></span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&quot;swiper&quot;</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;swiper-wrapper&quot;</span> style=&#123;&#123;height: <span class="string">&#x27;200px&#x27;</span>, background: <span class="string">&#x27;red&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        this.state.list.map(item =&gt; (</span><br><span class="line">                            &lt;div key=&#123;item&#125; className=<span class="string">&quot;swiper-slide&quot;</span>&gt;Slide &#123;item&#125;&lt;/div&gt;</span><br><span class="line">                        ))</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &#123;/* &lt;!-- 如果需要分页器 --&gt; */&#125;</span><br><span class="line">                &lt;div className=<span class="string">&quot;swiper-pagination&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">                </span><br><span class="line">                &#123;/* &lt;!-- 如果需要导航按钮 --&gt; */&#125;</span><br><span class="line">                &lt;div className=<span class="string">&quot;swiper-button-prev&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div className=<span class="string">&quot;swiper-button-next&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">                </span><br><span class="line">                &#123;/* &lt;!-- 如果需要滚动条 --&gt; */&#125;</span><br><span class="line">                &lt;div className=<span class="string">&quot;swiper-scrollbar&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-生命周期&quot;&gt;&lt;a href=&quot;#react-生命周期&quot; class=&quot;headerlink&quot; title=&quot;react 生命周期&quot;&gt;&lt;/a&gt;react 生命周期&lt;/h2&gt;&lt;h3 id=&quot;1-初始化阶段&quot;&gt;&lt;a href=&quot;#1-初始化阶段&quot; class</summary>
      
    
    
    
    <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>1.react基础用法之通信</title>
    <link href="http://yoursite.com/2022/10/05/react/1.react%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%B9%8B%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2022/10/05/react/1.react%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95%E4%B9%8B%E9%80%9A%E4%BF%A1/</id>
    <published>2022-10-05T02:28:00.000Z</published>
    <updated>2024-08-21T06:20:36.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react基础用法"><a href="#react基础用法" class="headerlink" title="react基础用法"></a>react基础用法</h2><h3 id="state状态"><a href="#state状态" class="headerlink" title="state状态"></a>state状态</h3><blockquote><ul><li>setState处在同步逻辑中，异步更新状态，更新真实dom</li><li>setState处在异步逻辑中，同步更新状态，同步更新真实dom</li><li>setState处在同步逻辑中 接受第二个参数，第二个参数是回调函数，状态和dom更新完后就会被处罚</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import BetterScroll from <span class="string">&#x27;better-scroll&#x27;</span>;</span><br><span class="line">    state = &#123;</span><br><span class="line">        list: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;button onClick=&#123;() =&gt; this.getData()&#125;&gt;click&lt;/button&gt;</span><br><span class="line">                &lt;div className=<span class="string">&#x27;wrapper&#x27;</span> style=&#123;&#123;height: <span class="string">&#x27;200px&#x27;</span>, backgroundColor: <span class="string">&#x27;red&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                    &lt;ul className=<span class="string">&#x27;content&#x27;</span> style=&#123;&#123;height: <span class="string">&#x27;100%&#x27;</span>, overflow: <span class="string">&#x27;auto&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            this.state.list.map(item =&gt; (</span><br><span class="line">                                &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">                            ))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getData</span></span> () &#123;</span><br><span class="line">        <span class="built_in">let</span> list = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            list.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            list: list</span><br><span class="line">        &#125;, () =&gt; &#123;</span><br><span class="line">            new BetterScroll(<span class="string">&#x27;.content&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="属性（props）"><a href="#属性（props）" class="headerlink" title="属性（props）"></a>属性（props）</h3><ul><li><code>prop-types</code> 验证方法</li><li><code>propTypes</code> prop校验规则</li><li><code>defaultProps</code> 默认值<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import kerwinPropTypes from <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="built_in">export</span> default class Navbar extends Component &#123;</span><br><span class="line">    <span class="comment"># prop 验证写法一</span></span><br><span class="line">    static propTypes = &#123;</span><br><span class="line">        title: kerwinPropTypes.string,</span><br><span class="line">        leftShow: kerwinPropTypes.bool</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># prop 默认值</span></span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        title: <span class="string">&#x27;首页1&#x27;</span>,</span><br><span class="line">        leftShow: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;this.props.leftShow &amp;&amp; &lt;button&gt;返回&lt;/button&gt;&#125;</span><br><span class="line">                navbar-&#123;this.props.title&#125;</span><br><span class="line">                &lt;button&gt;home&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># prop 验证写法二</span></span><br><span class="line">Navbar.propTypes = &#123;</span><br><span class="line">    title: kerwinPropTypes.string,</span><br><span class="line">    leftShow: kerwinPropTypes.bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="父子通信实战-表单处理"><a href="#父子通信实战-表单处理" class="headerlink" title="父子通信实战-表单处理"></a>父子通信实战-表单处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment"># 子级组建</span></span><br><span class="line">class Field extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        value: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">clear</span></span> () &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            value: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    setValue (value) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> &lt;div style=&#123;&#123;background: <span class="string">&#x27;#ddd&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">            &lt;label&gt;&#123;this.props.label&#125;&lt;/label&gt;</span><br><span class="line">            &lt;input <span class="built_in">type</span>=&#123;this.props.type&#125; onChange=&#123;(e) =&gt; &#123;</span><br><span class="line">                this.setValue(e.target.value)</span><br><span class="line">            &#125;&#125; value=&#123;this.state.value&#125;&gt;&lt;/input&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 父级表单组建</span></span><br><span class="line"><span class="built_in">export</span> default class App extends Component &#123;</span><br><span class="line">    username = React.createRef()</span><br><span class="line">    password = React.createRef()</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;登录组建&lt;/h1&gt;</span><br><span class="line">            &lt;Field label=<span class="string">&quot;用户名&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> ref=&#123;this.username&#125;&gt;&lt;/Field&gt;</span><br><span class="line">            &lt;Field label=<span class="string">&quot;密码&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;password&quot;</span> ref=&#123;this.password&#125; &gt;&lt;/Field&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                console.log(this.username.current.state.value, 123123)</span><br><span class="line">                console.log(this.password.current.state.value, 123123)</span><br><span class="line">            &#125;&#125;&gt;登录&lt;/button&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">                this.username.current.clear()</span><br><span class="line">                this.password.current.clear()</span><br><span class="line">            &#125;&#125;&gt;取消&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><h4 id="1-状态提升（中间人模式）"><a href="#1-状态提升（中间人模式）" class="headerlink" title="1.状态提升（中间人模式）"></a>1.状态提升（中间人模式）</h4><p>在父级进行状态管理，子级参数互传，父级管理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        filmList: [],</span><br><span class="line">        synopsis: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">        super()</span><br><span class="line">        axios.get(<span class="string">&#x27;/test.json&#x27;</span>).<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                filmList: res.data.data.films</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                this.state.filmList.map(item =&gt;&lt;FilmItem key=&#123;item.filmId&#125; &#123;...item&#125; onClickEvent=&#123;(value) =&gt; &#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        synopsis: value</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;&gt;&lt;/FilmItem&gt;)</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;FilmDetail synopsis=&#123;this.state.synopsis&#125;&gt;&lt;/FilmDetail&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FilmItem extends Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        const &#123;name, poster, synopsis&#125; = this.props</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;filmItem&#x27;</span> onClick=&#123;() =&gt; this.props.onClickEvent(synopsis)&#125;&gt;</span><br><span class="line">                &lt;img src=&#123;poster&#125; alt=&#123;name&#125; /&gt;</span><br><span class="line">                &lt;h4&gt;&#123;name&#125;&lt;/h4&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FilmDetail extends Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;filmDetail&#x27;</span>&gt;&#123;this.props.synopsis&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-发布订阅设计模式"><a href="#2-发布订阅设计模式" class="headerlink" title="2.发布订阅设计模式"></a>2.发布订阅设计模式</h4><h5 id="初级代码"><a href="#初级代码" class="headerlink" title="初级代码"></a>初级代码</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 状态管理系统</span></span><br><span class="line"><span class="built_in">let</span> bus = &#123;</span><br><span class="line">    list: [],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订阅</span></span><br><span class="line">    subscribe (callback) &#123;</span><br><span class="line">        this.list.push(callback)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发布</span></span><br><span class="line">    <span class="function"><span class="title">publish</span></span> () &#123;</span><br><span class="line">        this.list.map(callback =&gt;  callback &amp;&amp; callback())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 订阅</span></span><br><span class="line">bus.subscribe(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="number">1111111111</span>)</span><br><span class="line">&#125;)</span><br><span class="line"># 订阅</span><br><span class="line">bus.subscribe(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="number">22222222222</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 发布者</span><br><span class="line">bus.publish()</span><br></pre></td></tr></table></figure><h5 id="react-兄弟组件之间传参应用订阅模式"><a href="#react-兄弟组件之间传参应用订阅模式" class="headerlink" title="react 兄弟组件之间传参应用订阅模式"></a>react 兄弟组件之间传参应用订阅模式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅发布系统</span></span><br><span class="line"><span class="built_in">let</span> bus = &#123;</span><br><span class="line">    list: [],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订阅</span></span><br><span class="line">    subscribe (callback) &#123;</span><br><span class="line">        this.list.push(callback)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发布</span></span><br><span class="line">    publish (synopsis) &#123;</span><br><span class="line">        this.list.map(callback =&gt;  callback &amp;&amp; callback(synopsis))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父级渲染，不作处理</span></span><br><span class="line"><span class="built_in">export</span> default class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        filmList: [],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">        super()</span><br><span class="line">        axios.get(<span class="string">&#x27;/test.json&#x27;</span>).<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                filmList: res.data.data.films</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                this.state.filmList.map(item =&gt;&lt;FilmItem key=&#123;item.filmId&#125; &#123;...item&#125; &gt;&lt;/FilmItem&gt;)</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;FilmDetail&gt;&lt;/FilmDetail&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表子级 点击事件进行 发布模式</span></span><br><span class="line">class FilmItem extends Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        const &#123;name, poster, synopsis&#125; = this.props</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">&#x27;filmItem&#x27;</span> onClick=&#123;() =&gt; &#123;</span><br><span class="line">                bus.publish(synopsis) <span class="comment"># 调用发布</span></span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                &lt;img src=&#123;poster&#125; alt=&#123;name&#125; /&gt;</span><br><span class="line">                &lt;h4&gt;&#123;name&#125;&lt;/h4&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 详情子级 初始化时 直接进行订阅</span></span><br><span class="line">class FilmDetail extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        synopsis: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">        super()</span><br><span class="line">        <span class="comment"># 订阅模式</span></span><br><span class="line">        bus.subscribe((test) =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                synopsis: test</span><br><span class="line">            &#125;)</span><br><span class="line">            console.log(test, &#x27;订阅&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#x27;filmDetail&#x27;&gt;&#123;this.state.synopsis&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-context"><a href="#3-context" class="headerlink" title="3.context"></a>3.context</h4><p>创建上下文对象<br><strong>GlobalContext.Provider</strong><br><strong>GlobalContext.Consumer</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父级 定义一个info状态变量</span></span><br><span class="line"><span class="comment"># 通过value里面定义setInfo进行状态修改，重来重新进行render渲染</span></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        filmList: [],</span><br><span class="line">        info: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span></span> () &#123;</span><br><span class="line">        super()</span><br><span class="line">        axios.get(<span class="string">&#x27;/test.json&#x27;</span>).<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                filmList: res.data.data.films</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;GlobalContext.Provider value=&#123;&#123;</span><br><span class="line">                call: <span class="string">&#x27;打电话&#x27;</span>,</span><br><span class="line">                sms: <span class="string">&quot;短信&quot;</span>,</span><br><span class="line">                info: this.state.info,</span><br><span class="line">                setInfo: (info) =&gt; &#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        info</span><br><span class="line">                    &#125;)</span><br><span class="line">                    console.log(this.state.info)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        this.state.filmList.map(item =&gt;&lt;FilmItem key=&#123;item.filmId&#125; &#123;...item&#125;&gt;&lt;/FilmItem&gt;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    &lt;FilmDetail&gt;&lt;/FilmDetail&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/GlobalContext.Provider&gt;</span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FilmItem extends Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        const &#123;name, poster, synopsis&#125; = this.props</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;GlobalContext.Consumer&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    (value) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">return</span> (</span><br><span class="line">                            &lt;div className=<span class="string">&#x27;filmItem&#x27;</span> onClick=&#123;() =&gt; &#123;</span><br><span class="line">                                value.setInfo(synopsis)</span><br><span class="line">                            &#125;&#125;&gt;</span><br><span class="line">                                &lt;img src=&#123;poster&#125; alt=&#123;name&#125; /&gt;</span><br><span class="line">                                &lt;h4&gt;&#123;name&#125;&lt;/h4&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/GlobalContext.Consumer&gt;</span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FilmDetail extends Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;GlobalContext.Consumer&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    (value) =&gt; &lt;div className=<span class="string">&#x27;filmDetail&#x27;</span>&gt;&#123;value.info&#125;&lt;/div&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/GlobalContext.Consumer&gt;</span><br><span class="line">            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h4 id="基本插槽的用法"><a href="#基本插槽的用法" class="headerlink" title="基本插槽的用法"></a>基本插槽的用法</h4><blockquote><ul><li>1.为了复用</li><li>2.减少父子通信</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Child</span><br><span class="line">                &#123;this.props.children[2]&#125;</span><br><span class="line">                &#123;this.props.children[1]&#125;</span><br><span class="line">                &#123;this.props.children[0]&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child title=<span class="string">&quot;12312321&quot;</span>&gt;</span><br><span class="line">            &lt;p style=&#123;&#123;color: <span class="string">&#x27;red&#x27;</span>, fontSize: <span class="string">&#x27;18px&#x27;</span>&#125;&#125;&gt;11111111&lt;/p&gt;</span><br><span class="line">            &lt;p style=&#123;&#123;color: <span class="string">&#x27;red&#x27;</span>, fontSize: <span class="string">&#x27;18px&#x27;</span>&#125;&#125;&gt;222&lt;/p&gt;</span><br><span class="line">            &lt;p style=&#123;&#123;color: <span class="string">&#x27;red&#x27;</span>, fontSize: <span class="string">&#x27;18px&#x27;</span>&#125;&#125;&gt;3333&lt;/p&gt;</span><br><span class="line">        &lt;/Child&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react基础用法&quot;&gt;&lt;a href=&quot;#react基础用法&quot; class=&quot;headerlink&quot; title=&quot;react基础用法&quot;&gt;&lt;/a&gt;react基础用法&lt;/h2&gt;&lt;h3 id=&quot;state状态&quot;&gt;&lt;a href=&quot;#state状态&quot; class=&quot;he</summary>
      
    
    
    
    <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
    <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>3_vue3学习之组件之间的通信</title>
    <link href="http://yoursite.com/2022/01/12/vue/3_vue3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2022/01/12/vue/3_vue3%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2022-01-12T08:20:00.000Z</published>
    <updated>2024-08-21T06:20:36.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-使用props"><a href="#1-使用props" class="headerlink" title="1.使用props"></a>1.使用props</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String,</span><br><span class="line">    index: number,</span><br><span class="line">  &#125;</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    <span class="comment"># 该入参包含了我们定义的所有props</span></span><br><span class="line">    console.log(props)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="2-获取非prop的Attribute"><a href="#2-获取非prop的Attribute" class="headerlink" title="2.获取非prop的Attribute"></a>2.获取非prop的Attribute</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default defineComponent(&#123;</span><br><span class="line">  setup (props, &#123; attrs &#125;) &#123;</span><br><span class="line">    <span class="comment"># attrs 是个对象，每个 Attribute 都是它的 key</span></span><br><span class="line">    console.log(attrs.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果传下来的 Attribute 带有短横线，需要通过这种方式获取</span></span><br><span class="line">    console.log(attrs[<span class="string">&#x27;data-hash&#x27;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 指定继承 --&gt;</span><br><span class="line">  &lt;p v-bind=<span class="string">&quot;attrs&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 指定继承 --&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- 这些不会自动继承 --&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 这些不会自动继承 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="3-emits的使用"><a href="#3-emits的使用" class="headerlink" title="3.emits的使用"></a>3.emits的使用</h1><h2 id="emits时做一些校验"><a href="#emits时做一些校验" class="headerlink" title="emits时做一些校验"></a>emits时做一些校验</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chid中</span></span><br><span class="line"><span class="built_in">export</span> default defineComponent(&#123;</span><br><span class="line">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  emits: &#123;</span><br><span class="line">    <span class="comment"># 需要校验</span></span><br><span class="line">    <span class="string">&#x27;update-age&#x27;</span>: (age: number) =&gt; &#123;</span><br><span class="line">      <span class="comment"># 写一些条件拦截，记得返回false</span></span><br><span class="line">      <span class="keyword">if</span> (age &lt; 18) &#123;</span><br><span class="line">        console.log(<span class="string">&#x27;未成年不允许参与&#x27;</span>)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment"># 通过则返回true&#x27;</span></span><br><span class="line">      <span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (prop, &#123;emit &#125;) &#123;</span><br><span class="line">    const updateAge = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      emit(<span class="string">&#x27;update-age&#x27;</span>, 20)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      updateAge,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="emits父级绑定"><a href="#emits父级绑定" class="headerlink" title="emits父级绑定"></a>emits父级绑定</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line">import &#123; defineComponent&#125; from <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">import Child from <span class="string">&#x27;@cp/Child.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default defineComponent(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setup</span></span>() &#123;</span><br><span class="line">    <span class="comment"># emit调用</span></span><br><span class="line">    const updateAge = <span class="keyword">function</span> (data) &#123;</span><br><span class="line">      console.log(data, 897987)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      updateAge</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-使用props&quot;&gt;&lt;a href=&quot;#1-使用props&quot; class=&quot;headerlink&quot; title=&quot;1.使用props&quot;&gt;&lt;/a&gt;1.使用props&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
    <category term="vue3" scheme="http://yoursite.com/tags/vue3/"/>
    
  </entry>
  
</feed>
